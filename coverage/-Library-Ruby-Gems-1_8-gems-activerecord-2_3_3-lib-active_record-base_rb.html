<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title>/Library/Ruby/Gems/1.8/gems/activerecord-2.3.3/lib/active_record/base.rb</title>
    <link href="screen.css" media="all" rel="stylesheet" type="text/css" />
    <link href="print.css" media="print" rel="stylesheet" type="text/css" />
    
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <script type="text/javascript" src="rcov.js"></script>
  </head>
  <body>
    <h1>Rails Rrdtool C0 Coverage Information - RCov</h1>
    <h2>/Library/Ruby/Gems/1.8/gems/activerecord-2.3.3/lib/active_record/base.rb</h2>

    

    <div class="report_table_wrapper">
      <table class='report' id='report_table'>
        <thead>
          <tr>
            <th class="left_align">Name</th>
            <th class="right_align">Total Lines</th>
            <th class="right_align">Lines of Code</th>
            <th class="left_align">Total Coverage</th>
            <th class="left_align">Code Coverage</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="left_align"><a href="-Library-Ruby-Gems-1_8-gems-activerecord-2_3_3-lib-active_record-base_rb.html">/Library/Ruby/Gems/1.8/gems/activerecord-2.3.3/lib/active_record/base.rb</a></td>
            <td class='right_align'><tt>3150</tt></td>
            <td class='right_align'><tt>1466</tt></td>
            <td class="left_align"><div class="percent_graph_legend"><tt class=''>58.06%</tt></div>
          <div class="percent_graph">
            <div class="covered" style="width:58px"></div>
            <div class="uncovered" style="width:42px"></div>
          </div></td>
            <td class="left_align"><div class="percent_graph_legend"><tt class=''>20.12%</tt></div>
          <div class="percent_graph">
            <div class="covered" style="width:20px"></div>
            <div class="uncovered" style="width:80px"></div>
          </div></td>
          </tr>
        </tbody>
      </table>
    </div>
    
    <h3>Key</h3>
    
    <div class="key"><pre><span class='marked'>Code reported as executed by Ruby looks like this...</span><span class='marked1'>and this: this line is also marked as covered.</span><span class='inferred'>Lines considered as run by rcov, but not reported by Ruby, look like this,</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).</span><span class='uncovered'>Finally, here's a line marked as not executed.</span></pre></div>

    <h3>Coverage Details</h3>

    <table class="details">
      <tbody>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1">1</a> require 'yaml'</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2">2</a> require 'set'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3">3</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line4">4</a> module ActiveRecord #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line5">5</a>   # Generic Active Record exception class.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line6">6</a>   class ActiveRecordError &lt; StandardError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line7">7</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line8">8</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line9">9</a>   # Raised when the single-table inheritance mechanism fails to locate the subclass</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line10">10</a>   # (for example due to improper usage of column that +inheritance_column+ points to).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line11">11</a>   class SubclassNotFound &lt; ActiveRecordError #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line12">12</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line13">13</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line14">14</a>   # Raised when an object assigned to an association has an incorrect type.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line15">15</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line16">16</a>   #   class Ticket &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line17">17</a>   #     has_many :patches</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line18">18</a>   #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line19">19</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line20">20</a>   #   class Patch &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line21">21</a>   #     belongs_to :ticket</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line22">22</a>   #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line23">23</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line24">24</a>   #   # Comments are not patches, this assignment raises AssociationTypeMismatch.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line25">25</a>   #   @ticket.patches &lt;&lt; Comment.new(:content =&gt; &quot;Please attach tests to your patch.&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line26">26</a>   class AssociationTypeMismatch &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line27">27</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line28">28</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line29">29</a>   # Raised when unserialized object's type mismatches one specified for serializable field.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line30">30</a>   class SerializationTypeMismatch &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line31">31</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line32">32</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line33">33</a>   # Raised when adapter not specified on connection (or configuration file &lt;tt&gt;config/database.yml&lt;/tt&gt; misses adapter field).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line34">34</a>   class AdapterNotSpecified &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line35">35</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line36">36</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line37">37</a>   # Raised when Active Record cannot find database adapter specified in &lt;tt&gt;config/database.yml&lt;/tt&gt; or programmatically.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line38">38</a>   class AdapterNotFound &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line39">39</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line40">40</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line41">41</a>   # Raised when connection to the database could not been established (for example when &lt;tt&gt;connection=&lt;/tt&gt; is given a nil object).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line42">42</a>   class ConnectionNotEstablished &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line43">43</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line44">44</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line45">45</a>   # Raised when Active Record cannot find record by given id or set of ids.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line46">46</a>   class RecordNotFound &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line47">47</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line48">48</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line49">49</a>   # Raised by ActiveRecord::Base.save! and ActiveRecord::Base.create! methods when record cannot be</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line50">50</a>   # saved because record is invalid.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line51">51</a>   class RecordNotSaved &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line52">52</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line53">53</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line54">54</a>   # Raised when SQL statement cannot be executed by the database (for example, it's often the case for MySQL when Ruby driver used is too old).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line55">55</a>   class StatementInvalid &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line56">56</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line57">57</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line58">58</a>   # Raised when number of bind variables in statement given to &lt;tt&gt;:condition&lt;/tt&gt; key (for example, when using +find+ method)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line59">59</a>   # does not match number of expected variables.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line60">60</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line61">61</a>   # For example, in</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line62">62</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line63">63</a>   #   Location.find :all, :conditions =&gt; [&quot;lat = ? AND lng = ?&quot;, 53.7362]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line64">64</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line65">65</a>   # two placeholders are given but only one variable to fill them.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line66">66</a>   class PreparedStatementInvalid &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line67">67</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line68">68</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line69">69</a>   # Raised on attempt to save stale record. Record is stale when it's being saved in another query after</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line70">70</a>   # instantiation, for example, when two users edit the same wiki page and one starts editing and saves</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line71">71</a>   # the page before the other.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line72">72</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line73">73</a>   # Read more about optimistic locking in ActiveRecord::Locking module RDoc.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line74">74</a>   class StaleObjectError &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line75">75</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line76">76</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line77">77</a>   # Raised when association is being configured improperly or</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line78">78</a>   # user tries to use offset and limit together with has_many or has_and_belongs_to_many associations.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line79">79</a>   class ConfigurationError &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line80">80</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line81">81</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line82">82</a>   # Raised on attempt to update record that is instantiated as read only.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line83">83</a>   class ReadOnlyRecord &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line84">84</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line85">85</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line86">86</a>   # ActiveRecord::Transactions::ClassMethods.transaction uses this exception</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line87">87</a>   # to distinguish a deliberate rollback from other exceptional situations.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line88">88</a>   # Normally, raising an exception will cause the +transaction+ method to rollback</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line89">89</a>   # the database transaction *and* pass on the exception. But if you raise an</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line90">90</a>   # ActiveRecord::Rollback exception, then the database transaction will be rolled back,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line91">91</a>   # without passing on the exception.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line92">92</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line93">93</a>   # For example, you could do this in your controller to rollback a transaction:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line94">94</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line95">95</a>   #   class BooksController &lt; ActionController::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line96">96</a>   #     def create</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line97">97</a>   #       Book.transaction do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line98">98</a>   #         book = Book.new(params[:book])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line99">99</a>   #         book.save!</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line100">100</a>   #         if today_is_friday?</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line101">101</a>   #           # The system must fail on Friday so that our support department</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line102">102</a>   #           # won't be out of job. We silently rollback this transaction</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line103">103</a>   #           # without telling the user.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line104">104</a>   #           raise ActiveRecord::Rollback, &quot;Call tech support!&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line105">105</a>   #         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line106">106</a>   #       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line107">107</a>   #       # ActiveRecord::Rollback is the only exception that won't be passed on</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line108">108</a>   #       # by ActiveRecord::Base.transaction, so this line will still be reached</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line109">109</a>   #       # even on Friday.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line110">110</a>   #       redirect_to root_url</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line111">111</a>   #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line112">112</a>   #   end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line113">113</a>   class Rollback &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line114">114</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line115">115</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line116">116</a>   # Raised when attribute has a name reserved by Active Record (when attribute has name of one of Active Record instance methods).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line117">117</a>   class DangerousAttributeError &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line118">118</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line119">119</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line120">120</a>   # Raised when you've tried to access a column which wasn't loaded by your finder.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line121">121</a>   # Typically this is because &lt;tt&gt;:select&lt;/tt&gt; has been specified.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line122">122</a>   class MissingAttributeError &lt; NoMethodError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line123">123</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line124">124</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line125">125</a>   # Raised when unknown attributes are supplied via mass assignment.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line126">126</a>   class UnknownAttributeError &lt; NoMethodError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line127">127</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line128">128</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line129">129</a>   # Raised when an error occurred while doing a mass assignment to an attribute through the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line130">130</a>   # &lt;tt&gt;attributes=&lt;/tt&gt; method. The exception has an +attribute+ property that is the name of the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line131">131</a>   # offending attribute.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line132">132</a>   class AttributeAssignmentError &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line133">133</a>     attr_reader :exception, :attribute</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line134">134</a>     def initialize(message, exception, attribute)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line135">135</a>       @exception = exception</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line136">136</a>       @attribute = attribute</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line137">137</a>       @message = message</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line138">138</a>     end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line139">139</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line140">140</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line141">141</a>   # Raised when there are multiple errors while doing a mass assignment through the +attributes+</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line142">142</a>   # method. The exception has an +errors+ property that contains an array of AttributeAssignmentError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line143">143</a>   # objects, each corresponding to the error while assigning to an attribute.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line144">144</a>   class MultiparameterAssignmentErrors &lt; ActiveRecordError</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line145">145</a>     attr_reader :errors</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line146">146</a>     def initialize(errors)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line147">147</a>       @errors = errors</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line148">148</a>     end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line149">149</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line150">150</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line151">151</a>   # Active Record objects don't specify their attributes directly, but rather infer them from the table definition with</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line152">152</a>   # which they're linked. Adding, removing, and changing attributes and their type is done directly in the database. Any change</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line153">153</a>   # is instantly reflected in the Active Record objects. The mapping that binds a given Active Record class to a certain</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line154">154</a>   # database table will happen automatically in most common cases, but can be overwritten for the uncommon ones.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line155">155</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line156">156</a>   # See the mapping rules in table_name and the full example in link:files/README.html for more insight.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line157">157</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line158">158</a>   # == Creation</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line159">159</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line160">160</a>   # Active Records accept constructor parameters either in a hash or as a block. The hash method is especially useful when</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line161">161</a>   # you're receiving the data from somewhere else, like an HTTP request. It works like this:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line162">162</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line163">163</a>   #   user = User.new(:name =&gt; &quot;David&quot;, :occupation =&gt; &quot;Code Artist&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line164">164</a>   #   user.name # =&gt; &quot;David&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line165">165</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line166">166</a>   # You can also use block initialization:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line167">167</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line168">168</a>   #   user = User.new do |u|</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line169">169</a>   #     u.name = &quot;David&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line170">170</a>   #     u.occupation = &quot;Code Artist&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line171">171</a>   #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line172">172</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line173">173</a>   # And of course you can just create a bare object and specify the attributes after the fact:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line174">174</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line175">175</a>   #   user = User.new</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line176">176</a>   #   user.name = &quot;David&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line177">177</a>   #   user.occupation = &quot;Code Artist&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line178">178</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line179">179</a>   # == Conditions</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line180">180</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line181">181</a>   # Conditions can either be specified as a string, array, or hash representing the WHERE-part of an SQL statement.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line182">182</a>   # The array form is to be used when the condition input is tainted and requires sanitization. The string form can</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line183">183</a>   # be used for statements that don't involve tainted data. The hash form works much like the array form, except</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line184">184</a>   # only equality and range is possible. Examples:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line185">185</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line186">186</a>   #   class User &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line187">187</a>   #     def self.authenticate_unsafely(user_name, password)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line188">188</a>   #       find(:first, :conditions =&gt; &quot;user_name = '#{user_name}' AND password = '#{password}'&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line189">189</a>   #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line190">190</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line191">191</a>   #     def self.authenticate_safely(user_name, password)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line192">192</a>   #       find(:first, :conditions =&gt; [ &quot;user_name = ? AND password = ?&quot;, user_name, password ])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line193">193</a>   #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line194">194</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line195">195</a>   #     def self.authenticate_safely_simply(user_name, password)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line196">196</a>   #       find(:first, :conditions =&gt; { :user_name =&gt; user_name, :password =&gt; password })</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line197">197</a>   #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line198">198</a>   #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line199">199</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line200">200</a>   # The &lt;tt&gt;authenticate_unsafely&lt;/tt&gt; method inserts the parameters directly into the query and is thus susceptible to SQL-injection</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line201">201</a>   # attacks if the &lt;tt&gt;user_name&lt;/tt&gt; and +password+ parameters come directly from an HTTP request. The &lt;tt&gt;authenticate_safely&lt;/tt&gt;  and</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line202">202</a>   # &lt;tt&gt;authenticate_safely_simply&lt;/tt&gt; both will sanitize the &lt;tt&gt;user_name&lt;/tt&gt; and +password+ before inserting them in the query,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line203">203</a>   # which will ensure that an attacker can't escape the query and fake the login (or worse).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line204">204</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line205">205</a>   # When using multiple parameters in the conditions, it can easily become hard to read exactly what the fourth or fifth</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line206">206</a>   # question mark is supposed to represent. In those cases, you can resort to named bind variables instead. That's done by replacing</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line207">207</a>   # the question marks with symbols and supplying a hash with values for the matching symbol keys:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line208">208</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line209">209</a>   #   Company.find(:first, :conditions =&gt; [</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line210">210</a>   #     &quot;id = :id AND name = :name AND division = :division AND created_at &gt; :accounting_date&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line211">211</a>   #     { :id =&gt; 3, :name =&gt; &quot;37signals&quot;, :division =&gt; &quot;First&quot;, :accounting_date =&gt; '2005-01-01' }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line212">212</a>   #   ])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line213">213</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line214">214</a>   # Similarly, a simple hash without a statement will generate conditions based on equality with the SQL AND</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line215">215</a>   # operator. For instance:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line216">216</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line217">217</a>   #   Student.find(:all, :conditions =&gt; { :first_name =&gt; &quot;Harvey&quot;, :status =&gt; 1 })</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line218">218</a>   #   Student.find(:all, :conditions =&gt; params[:student])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line219">219</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line220">220</a>   # A range may be used in the hash to use the SQL BETWEEN operator:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line221">221</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line222">222</a>   #   Student.find(:all, :conditions =&gt; { :grade =&gt; 9..12 })</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line223">223</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line224">224</a>   # An array may be used in the hash to use the SQL IN operator:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line225">225</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line226">226</a>   #   Student.find(:all, :conditions =&gt; { :grade =&gt; [9,11,12] })</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line227">227</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line228">228</a>   # == Overwriting default accessors</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line229">229</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line230">230</a>   # All column values are automatically available through basic accessors on the Active Record object, but sometimes you</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line231">231</a>   # want to specialize this behavior. This can be done by overwriting the default accessors (using the same</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line232">232</a>   # name as the attribute) and calling &lt;tt&gt;read_attribute(attr_name)&lt;/tt&gt; and &lt;tt&gt;write_attribute(attr_name, value)&lt;/tt&gt; to actually change things.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line233">233</a>   # Example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line234">234</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line235">235</a>   #   class Song &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line236">236</a>   #     # Uses an integer of seconds to hold the length of the song</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line237">237</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line238">238</a>   #     def length=(minutes)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line239">239</a>   #       write_attribute(:length, minutes.to_i * 60)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line240">240</a>   #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line241">241</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line242">242</a>   #     def length</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line243">243</a>   #       read_attribute(:length) / 60</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line244">244</a>   #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line245">245</a>   #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line246">246</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line247">247</a>   # You can alternatively use &lt;tt&gt;self[:attribute]=(value)&lt;/tt&gt; and &lt;tt&gt;self[:attribute]&lt;/tt&gt; instead of &lt;tt&gt;write_attribute(:attribute, value)&lt;/tt&gt; and</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line248">248</a>   # &lt;tt&gt;read_attribute(:attribute)&lt;/tt&gt; as a shorter form.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line249">249</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line250">250</a>   # == Attribute query methods</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line251">251</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line252">252</a>   # In addition to the basic accessors, query methods are also automatically available on the Active Record object.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line253">253</a>   # Query methods allow you to test whether an attribute value is present.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line254">254</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line255">255</a>   # For example, an Active Record User with the &lt;tt&gt;name&lt;/tt&gt; attribute has a &lt;tt&gt;name?&lt;/tt&gt; method that you can call</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line256">256</a>   # to determine whether the user has a name:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line257">257</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line258">258</a>   #   user = User.new(:name =&gt; &quot;David&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line259">259</a>   #   user.name? # =&gt; true</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line260">260</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line261">261</a>   #   anonymous = User.new(:name =&gt; &quot;&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line262">262</a>   #   anonymous.name? # =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line263">263</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line264">264</a>   # == Accessing attributes before they have been typecasted</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line265">265</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line266">266</a>   # Sometimes you want to be able to read the raw attribute data without having the column-determined typecast run its course first.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line267">267</a>   # That can be done by using the &lt;tt&gt;&lt;attribute&gt;_before_type_cast&lt;/tt&gt; accessors that all attributes have. For example, if your Account model</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line268">268</a>   # has a &lt;tt&gt;balance&lt;/tt&gt; attribute, you can call &lt;tt&gt;account.balance_before_type_cast&lt;/tt&gt; or &lt;tt&gt;account.id_before_type_cast&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line269">269</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line270">270</a>   # This is especially useful in validation situations where the user might supply a string for an integer field and you want to display</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line271">271</a>   # the original string back in an error message. Accessing the attribute normally would typecast the string to 0, which isn't what you</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line272">272</a>   # want.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line273">273</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line274">274</a>   # == Dynamic attribute-based finders</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line275">275</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line276">276</a>   # Dynamic attribute-based finders are a cleaner way of getting (and/or creating) objects by simple queries without turning to SQL. They work by</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line277">277</a>   # appending the name of an attribute to &lt;tt&gt;find_by_&lt;/tt&gt;, &lt;tt&gt;find_last_by_&lt;/tt&gt;, or &lt;tt&gt;find_all_by_&lt;/tt&gt;, so you get finders like &lt;tt&gt;Person.find_by_user_name&lt;/tt&gt;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line278">278</a>   # &lt;tt&gt;Person.find_all_by_last_name&lt;/tt&gt;, and &lt;tt&gt;Payment.find_by_transaction_id&lt;/tt&gt;. So instead of writing</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line279">279</a>   # &lt;tt&gt;Person.find(:first, :conditions =&gt; [&quot;user_name = ?&quot;, user_name])&lt;/tt&gt;, you just do &lt;tt&gt;Person.find_by_user_name(user_name)&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line280">280</a>   # And instead of writing &lt;tt&gt;Person.find(:all, :conditions =&gt; [&quot;last_name = ?&quot;, last_name])&lt;/tt&gt;, you just do &lt;tt&gt;Person.find_all_by_last_name(last_name)&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line281">281</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line282">282</a>   # It's also possible to use multiple attributes in the same find by separating them with &quot;_and_&quot;, so you get finders like</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line283">283</a>   # &lt;tt&gt;Person.find_by_user_name_and_password&lt;/tt&gt; or even &lt;tt&gt;Payment.find_by_purchaser_and_state_and_country&lt;/tt&gt;. So instead of writing</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line284">284</a>   # &lt;tt&gt;Person.find(:first, :conditions =&gt; [&quot;user_name = ? AND password = ?&quot;, user_name, password])&lt;/tt&gt;, you just do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line285">285</a>   # &lt;tt&gt;Person.find_by_user_name_and_password(user_name, password)&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line286">286</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line287">287</a>   # It's even possible to use all the additional parameters to find. For example, the full interface for &lt;tt&gt;Payment.find_all_by_amount&lt;/tt&gt;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line288">288</a>   # is actually &lt;tt&gt;Payment.find_all_by_amount(amount, options)&lt;/tt&gt;. And the full interface to &lt;tt&gt;Person.find_by_user_name&lt;/tt&gt; is</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line289">289</a>   # actually &lt;tt&gt;Person.find_by_user_name(user_name, options)&lt;/tt&gt;. So you could call &lt;tt&gt;Payment.find_all_by_amount(50, :order =&gt; &quot;created_on&quot;)&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line290">290</a>   # Also you may call &lt;tt&gt;Payment.find_last_by_amount(amount, options)&lt;/tt&gt; returning the last record matching that amount and options.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line291">291</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line292">292</a>   # The same dynamic finder style can be used to create the object if it doesn't already exist. This dynamic finder is called with</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line293">293</a>   # &lt;tt&gt;find_or_create_by_&lt;/tt&gt; and will return the object if it already exists and otherwise creates it, then returns it. Protected attributes won't be set unless they are given in a block. For example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line294">294</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line295">295</a>   #   # No 'Summer' tag exists</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line296">296</a>   #   Tag.find_or_create_by_name(&quot;Summer&quot;) # equal to Tag.create(:name =&gt; &quot;Summer&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line297">297</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line298">298</a>   #   # Now the 'Summer' tag does exist</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line299">299</a>   #   Tag.find_or_create_by_name(&quot;Summer&quot;) # equal to Tag.find_by_name(&quot;Summer&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line300">300</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line301">301</a>   #   # Now 'Bob' exist and is an 'admin'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line302">302</a>   #   User.find_or_create_by_name('Bob', :age =&gt; 40) { |u| u.admin = true }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line303">303</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line304">304</a>   # Use the &lt;tt&gt;find_or_initialize_by_&lt;/tt&gt; finder if you want to return a new record without saving it first. Protected attributes won't be set unless they are given in a block. For example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line305">305</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line306">306</a>   #   # No 'Winter' tag exists</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line307">307</a>   #   winter = Tag.find_or_initialize_by_name(&quot;Winter&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line308">308</a>   #   winter.new_record? # true</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line309">309</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line310">310</a>   # To find by a subset of the attributes to be used for instantiating a new object, pass a hash instead of</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line311">311</a>   # a list of parameters. For example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line312">312</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line313">313</a>   #   Tag.find_or_create_by_name(:name =&gt; &quot;rails&quot;, :creator =&gt; current_user)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line314">314</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line315">315</a>   # That will either find an existing tag named &quot;rails&quot;, or create a new one while setting the user that created it.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line316">316</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line317">317</a>   # == Saving arrays, hashes, and other non-mappable objects in text columns</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line318">318</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line319">319</a>   # Active Record can serialize any object in text columns using YAML. To do so, you must specify this with a call to the class method +serialize+.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line320">320</a>   # This makes it possible to store arrays, hashes, and other non-mappable objects without doing any additional work. Example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line321">321</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line322">322</a>   #   class User &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line323">323</a>   #     serialize :preferences</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line324">324</a>   #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line325">325</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line326">326</a>   #   user = User.create(:preferences =&gt; { &quot;background&quot; =&gt; &quot;black&quot;, &quot;display&quot; =&gt; large })</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line327">327</a>   #   User.find(user.id).preferences # =&gt; { &quot;background&quot; =&gt; &quot;black&quot;, &quot;display&quot; =&gt; large }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line328">328</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line329">329</a>   # You can also specify a class option as the second parameter that'll raise an exception if a serialized object is retrieved as a</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line330">330</a>   # descendant of a class not in the hierarchy. Example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line331">331</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line332">332</a>   #   class User &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line333">333</a>   #     serialize :preferences, Hash</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line334">334</a>   #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line335">335</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line336">336</a>   #   user = User.create(:preferences =&gt; %w( one two three ))</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line337">337</a>   #   User.find(user.id).preferences    # raises SerializationTypeMismatch</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line338">338</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line339">339</a>   # == Single table inheritance</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line340">340</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line341">341</a>   # Active Record allows inheritance by storing the name of the class in a column that by default is named &quot;type&quot; (can be changed</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line342">342</a>   # by overwriting &lt;tt&gt;Base.inheritance_column&lt;/tt&gt;). This means that an inheritance looking like this:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line343">343</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line344">344</a>   #   class Company &lt; ActiveRecord::Base; end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line345">345</a>   #   class Firm &lt; Company; end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line346">346</a>   #   class Client &lt; Company; end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line347">347</a>   #   class PriorityClient &lt; Client; end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line348">348</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line349">349</a>   # When you do &lt;tt&gt;Firm.create(:name =&gt; &quot;37signals&quot;)&lt;/tt&gt;, this record will be saved in the companies table with type = &quot;Firm&quot;. You can then</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line350">350</a>   # fetch this row again using &lt;tt&gt;Company.find(:first, &quot;name = '37signals'&quot;)&lt;/tt&gt; and it will return a Firm object.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line351">351</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line352">352</a>   # If you don't have a type column defined in your table, single-table inheritance won't be triggered. In that case, it'll work just</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line353">353</a>   # like normal subclasses with no special magic for differentiating between them or reloading the right type with find.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line354">354</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line355">355</a>   # Note, all the attributes for all the cases are kept in the same table. Read more:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line356">356</a>   # http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line357">357</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line358">358</a>   # == Connection to multiple databases in different models</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line359">359</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line360">360</a>   # Connections are usually created through ActiveRecord::Base.establish_connection and retrieved by ActiveRecord::Base.connection.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line361">361</a>   # All classes inheriting from ActiveRecord::Base will use this connection. But you can also set a class-specific connection.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line362">362</a>   # For example, if Course is an ActiveRecord::Base, but resides in a different database, you can just say &lt;tt&gt;Course.establish_connection&lt;/tt&gt;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line363">363</a>   # and Course and all of its subclasses will use this connection instead.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line364">364</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line365">365</a>   # This feature is implemented by keeping a connection pool in ActiveRecord::Base that is a Hash indexed by the class. If a connection is</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line366">366</a>   # requested, the retrieve_connection method will go up the class-hierarchy until a connection is found in the connection pool.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line367">367</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line368">368</a>   # == Exceptions</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line369">369</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line370">370</a>   # * ActiveRecordError - Generic error class and superclass of all other errors raised by Active Record.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line371">371</a>   # * AdapterNotSpecified - The configuration hash used in &lt;tt&gt;establish_connection&lt;/tt&gt; didn't include an</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line372">372</a>   #   &lt;tt&gt;:adapter&lt;/tt&gt; key.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line373">373</a>   # * AdapterNotFound - The &lt;tt&gt;:adapter&lt;/tt&gt; key used in &lt;tt&gt;establish_connection&lt;/tt&gt; specified a non-existent adapter</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line374">374</a>   #   (or a bad spelling of an existing one).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line375">375</a>   # * AssociationTypeMismatch - The object assigned to the association wasn't of the type specified in the association definition.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line376">376</a>   # * SerializationTypeMismatch - The serialized object wasn't of the class specified as the second parameter.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line377">377</a>   # * ConnectionNotEstablished+ - No connection has been established. Use &lt;tt&gt;establish_connection&lt;/tt&gt; before querying.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line378">378</a>   # * RecordNotFound - No record responded to the +find+ method. Either the row with the given ID doesn't exist</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line379">379</a>   #   or the row didn't meet the additional restrictions. Some +find+ calls do not raise this exception to signal</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line380">380</a>   #   nothing was found, please check its documentation for further details.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line381">381</a>   # * StatementInvalid - The database server rejected the SQL statement. The precise error is added in the message.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line382">382</a>   # * MultiparameterAssignmentErrors - Collection of errors that occurred during a mass assignment using the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line383">383</a>   #   &lt;tt&gt;attributes=&lt;/tt&gt; method. The +errors+ property of this exception contains an array of AttributeAssignmentError</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line384">384</a>   #   objects that should be inspected to determine which attributes triggered the errors.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line385">385</a>   # * AttributeAssignmentError - An error occurred while doing a mass assignment through the &lt;tt&gt;attributes=&lt;/tt&gt; method.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line386">386</a>   #   You can inspect the +attribute+ property of the exception object to determine which attribute triggered the error.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line387">387</a>   #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line388">388</a>   # *Note*: The attributes listed are class-level attributes (accessible from both the class and instance level).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line389">389</a>   # So it's possible to assign a logger to the class through &lt;tt&gt;Base.logger=&lt;/tt&gt; which will then be used by all</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line390">390</a>   # instances in the current object space.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line391">391</a>   class Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line392">392</a>     ##  </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line393">393</a>     # :singleton-method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line394">394</a>     # Accepts a logger conforming to the interface of Log4r or the default Ruby 1.8+ Logger class, which is then passed</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line395">395</a>     # on to any new database connections made and which can be retrieved on both a class and instance level by calling +logger+.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line396">396</a>     cattr_accessor :logger, :instance_writer =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line397">397</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line398">398</a>     def self.inherited(child) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line399">399</a>       @@subclasses[self] ||= []</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line400">400</a>       @@subclasses[self] &lt;&lt; child</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line401">401</a>       super</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line402">402</a>     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line403">403</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line404">404</a>     def self.reset_subclasses #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line405">405</a>       nonreloadables = []</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line406">406</a>       subclasses.each do |klass|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line407">407</a>         unless ActiveSupport::Dependencies.autoloaded? klass</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line408">408</a>           nonreloadables &lt;&lt; klass</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line409">409</a>           next</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line410">410</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line411">411</a>         klass.instance_variables.each { |var| klass.send(:remove_instance_variable, var) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line412">412</a>         klass.instance_methods(false).each { |m| klass.send :undef_method, m }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line413">413</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line414">414</a>       @@subclasses = {}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line415">415</a>       nonreloadables.each { |klass| (@@subclasses[klass.superclass] ||= []) &lt;&lt; klass }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line416">416</a>     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line417">417</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line418">418</a>     @@subclasses = {}</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line419">419</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line420">420</a>     ##</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line421">421</a>     # :singleton-method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line422">422</a>     # Contains the database configuration - as is typically stored in config/database.yml -</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line423">423</a>     # as a Hash.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line424">424</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line425">425</a>     # For example, the following database.yml...</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line426">426</a>     # </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line427">427</a>     #   development:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line428">428</a>     #     adapter: sqlite3</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line429">429</a>     #     database: db/development.sqlite3</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line430">430</a>     #   </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line431">431</a>     #   production:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line432">432</a>     #     adapter: sqlite3</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line433">433</a>     #     database: db/production.sqlite3</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line434">434</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line435">435</a>     # ...would result in ActiveRecord::Base.configurations to look like this:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line436">436</a>     #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line437">437</a>     #   {</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line438">438</a>     #      'development' =&gt; {</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line439">439</a>     #         'adapter'  =&gt; 'sqlite3',</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line440">440</a>     #         'database' =&gt; 'db/development.sqlite3'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line441">441</a>     #      },</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line442">442</a>     #      'production' =&gt; {</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line443">443</a>     #         'adapter'  =&gt; 'sqlite3',</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line444">444</a>     #         'database' =&gt; 'db/production.sqlite3'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line445">445</a>     #      }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line446">446</a>     #   }</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line447">447</a>     cattr_accessor :configurations, :instance_writer =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line448">448</a>     @@configurations = {}</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line449">449</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line450">450</a>     ##</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line451">451</a>     # :singleton-method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line452">452</a>     # Accessor for the prefix type that will be prepended to every primary key column name. The options are :table_name and</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line453">453</a>     # :table_name_with_underscore. If the first is specified, the Product class will look for &quot;productid&quot; instead of &quot;id&quot; as</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line454">454</a>     # the primary column. If the latter is specified, the Product class will look for &quot;product_id&quot; instead of &quot;id&quot;. Remember</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line455">455</a>     # that this is a global setting for all Active Records.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line456">456</a>     cattr_accessor :primary_key_prefix_type, :instance_writer =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line457">457</a>     @@primary_key_prefix_type = nil</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line458">458</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line459">459</a>     ##</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line460">460</a>     # :singleton-method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line461">461</a>     # Accessor for the name of the prefix string to prepend to every table name. So if set to &quot;basecamp_&quot;, all</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line462">462</a>     # table names will be named like &quot;basecamp_projects&quot;, &quot;basecamp_people&quot;, etc. This is a convenient way of creating a namespace</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line463">463</a>     # for tables in a shared database. By default, the prefix is the empty string.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line464">464</a>     cattr_accessor :table_name_prefix, :instance_writer =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line465">465</a>     @@table_name_prefix = &quot;&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line466">466</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line467">467</a>     ##</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line468">468</a>     # :singleton-method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line469">469</a>     # Works like +table_name_prefix+, but appends instead of prepends (set to &quot;_basecamp&quot; gives &quot;projects_basecamp&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line470">470</a>     # &quot;people_basecamp&quot;). By default, the suffix is the empty string.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line471">471</a>     cattr_accessor :table_name_suffix, :instance_writer =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line472">472</a>     @@table_name_suffix = &quot;&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line473">473</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line474">474</a>     ##</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line475">475</a>     # :singleton-method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line476">476</a>     # Indicates whether table names should be the pluralized versions of the corresponding class names.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line477">477</a>     # If true, the default table name for a Product class will be +products+. If false, it would just be +product+.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line478">478</a>     # See table_name for the full rules on table/class naming. This is true, by default.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line479">479</a>     cattr_accessor :pluralize_table_names, :instance_writer =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line480">480</a>     @@pluralize_table_names = true</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line481">481</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line482">482</a>     ##</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line483">483</a>     # :singleton-method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line484">484</a>     # Determines whether to use ANSI codes to colorize the logging statements committed by the connection adapter. These colors</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line485">485</a>     # make it much easier to overview things during debugging (when used through a reader like +tail+ and on a black background), but</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line486">486</a>     # may complicate matters if you use software like syslog. This is true, by default.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line487">487</a>     cattr_accessor :colorize_logging, :instance_writer =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line488">488</a>     @@colorize_logging = true</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line489">489</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line490">490</a>     ##</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line491">491</a>     # :singleton-method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line492">492</a>     # Determines whether to use Time.local (using :local) or Time.utc (using :utc) when pulling dates and times from the database.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line493">493</a>     # This is set to :local by default.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line494">494</a>     cattr_accessor :default_timezone, :instance_writer =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line495">495</a>     @@default_timezone = :local</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line496">496</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line497">497</a>     ##</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line498">498</a>     # :singleton-method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line499">499</a>     # Specifies the format to use when dumping the database schema with Rails'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line500">500</a>     # Rakefile.  If :sql, the schema is dumped as (potentially database-</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line501">501</a>     # specific) SQL statements.  If :ruby, the schema is dumped as an</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line502">502</a>     # ActiveRecord::Schema file which can be loaded into any database that</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line503">503</a>     # supports migrations.  Use :ruby if you want to have different database</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line504">504</a>     # adapters for, e.g., your development and test environments.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line505">505</a>     cattr_accessor :schema_format , :instance_writer =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line506">506</a>     @@schema_format = :ruby</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line507">507</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line508">508</a>     ##</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line509">509</a>     # :singleton-method:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line510">510</a>     # Specify whether or not to use timestamps for migration numbers</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line511">511</a>     cattr_accessor :timestamped_migrations , :instance_writer =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line512">512</a>     @@timestamped_migrations = true</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line513">513</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line514">514</a>     # Determine whether to store the full constant name including namespace when using STI</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line515">515</a>     superclass_delegating_accessor :store_full_sti_class</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line516">516</a>     self.store_full_sti_class = false</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line517">517</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line518">518</a>     # Stores the default scope for the class</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line519">519</a>     class_inheritable_accessor :default_scoping, :instance_writer =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line520">520</a>     self.default_scoping = []</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line521">521</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line522">522</a>     class &lt;&lt; self # Class methods</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line523">523</a>       # Find operates with four different retrieval approaches:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line524">524</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line525">525</a>       # * Find by id - This can either be a specific id (1), a list of ids (1, 5, 6), or an array of ids ([5, 6, 10]).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line526">526</a>       #   If no record can be found for all of the listed ids, then RecordNotFound will be raised.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line527">527</a>       # * Find first - This will return the first record matched by the options used. These options can either be specific</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line528">528</a>       #   conditions or merely an order. If no record can be matched, +nil+ is returned. Use</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line529">529</a>       #   &lt;tt&gt;Model.find(:first, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.first(*args)&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line530">530</a>       # * Find last - This will return the last record matched by the options used. These options can either be specific</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line531">531</a>       #   conditions or merely an order. If no record can be matched, +nil+ is returned. Use</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line532">532</a>       #   &lt;tt&gt;Model.find(:last, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.last(*args)&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line533">533</a>       # * Find all - This will return all the records matched by the options used.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line534">534</a>       #   If no records are found, an empty array is returned. Use</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line535">535</a>       #   &lt;tt&gt;Model.find(:all, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.all(*args)&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line536">536</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line537">537</a>       # All approaches accept an options hash as their last parameter.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line538">538</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line539">539</a>       # ==== Parameters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line540">540</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line541">541</a>       # * &lt;tt&gt;:conditions&lt;/tt&gt; - An SQL fragment like &quot;administrator = 1&quot;, &lt;tt&gt;[ &quot;user_name = ?&quot;, username ]&lt;/tt&gt;, or &lt;tt&gt;[&quot;user_name = :user_name&quot;, { :user_name =&gt; user_name }]&lt;/tt&gt;. See conditions in the intro.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line542">542</a>       # * &lt;tt&gt;:order&lt;/tt&gt; - An SQL fragment like &quot;created_at DESC, name&quot;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line543">543</a>       # * &lt;tt&gt;:group&lt;/tt&gt; - An attribute name by which the result should be grouped. Uses the &lt;tt&gt;GROUP BY&lt;/tt&gt; SQL-clause.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line544">544</a>       # * &lt;tt&gt;:having&lt;/tt&gt; - Combined with +:group+ this can be used to filter the records that a &lt;tt&gt;GROUP BY&lt;/tt&gt; returns. Uses the &lt;tt&gt;HAVING&lt;/tt&gt; SQL-clause.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line545">545</a>       # * &lt;tt&gt;:limit&lt;/tt&gt; - An integer determining the limit on the number of rows that should be returned.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line546">546</a>       # * &lt;tt&gt;:offset&lt;/tt&gt; - An integer determining the offset from where the rows should be fetched. So at 5, it would skip rows 0 through 4.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line547">547</a>       # * &lt;tt&gt;:joins&lt;/tt&gt; - Either an SQL fragment for additional joins like &quot;LEFT JOIN comments ON comments.post_id = id&quot; (rarely needed),</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line548">548</a>       #   named associations in the same form used for the &lt;tt&gt;:include&lt;/tt&gt; option, which will perform an &lt;tt&gt;INNER JOIN&lt;/tt&gt; on the associated table(s),</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line549">549</a>       #   or an array containing a mixture of both strings and named associations.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line550">550</a>       #   If the value is a string, then the records will be returned read-only since they will have attributes that do not correspond to the table's columns.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line551">551</a>       #   Pass &lt;tt&gt;:readonly =&gt; false&lt;/tt&gt; to override.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line552">552</a>       # * &lt;tt&gt;:include&lt;/tt&gt; - Names associations that should be loaded alongside. The symbols named refer</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line553">553</a>       #   to already defined associations. See eager loading under Associations.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line554">554</a>       # * &lt;tt&gt;:select&lt;/tt&gt; - By default, this is &quot;*&quot; as in &quot;SELECT * FROM&quot;, but can be changed if you, for example, want to do a join but not</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line555">555</a>       #   include the joined columns. Takes a string with the SELECT SQL fragment (e.g. &quot;id, name&quot;).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line556">556</a>       # * &lt;tt&gt;:from&lt;/tt&gt; - By default, this is the table name of the class, but can be changed to an alternate table name (or even the name</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line557">557</a>       #   of a database view).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line558">558</a>       # * &lt;tt&gt;:readonly&lt;/tt&gt; - Mark the returned records read-only so they cannot be saved or updated.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line559">559</a>       # * &lt;tt&gt;:lock&lt;/tt&gt; - An SQL fragment like &quot;FOR UPDATE&quot; or &quot;LOCK IN SHARE MODE&quot;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line560">560</a>       #   &lt;tt&gt;:lock =&gt; true&lt;/tt&gt; gives connection's default exclusive lock, usually &quot;FOR UPDATE&quot;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line561">561</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line562">562</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line563">563</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line564">564</a>       #   # find by id</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line565">565</a>       #   Person.find(1)       # returns the object for ID = 1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line566">566</a>       #   Person.find(1, 2, 6) # returns an array for objects with IDs in (1, 2, 6)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line567">567</a>       #   Person.find([7, 17]) # returns an array for objects with IDs in (7, 17)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line568">568</a>       #   Person.find([1])     # returns an array for the object with ID = 1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line569">569</a>       #   Person.find(1, :conditions =&gt; &quot;administrator = 1&quot;, :order =&gt; &quot;created_on DESC&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line570">570</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line571">571</a>       # Note that returned records may not be in the same order as the ids you</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line572">572</a>       # provide since database rows are unordered. Give an explicit &lt;tt&gt;:order&lt;/tt&gt;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line573">573</a>       # to ensure the results are sorted.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line574">574</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line575">575</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line576">576</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line577">577</a>       #   # find first</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line578">578</a>       #   Person.find(:first) # returns the first object fetched by SELECT * FROM people</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line579">579</a>       #   Person.find(:first, :conditions =&gt; [ &quot;user_name = ?&quot;, user_name])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line580">580</a>       #   Person.find(:first, :conditions =&gt; [ &quot;user_name = :u&quot;, { :u =&gt; user_name }])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line581">581</a>       #   Person.find(:first, :order =&gt; &quot;created_on DESC&quot;, :offset =&gt; 5)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line582">582</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line583">583</a>       #   # find last</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line584">584</a>       #   Person.find(:last) # returns the last object fetched by SELECT * FROM people</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line585">585</a>       #   Person.find(:last, :conditions =&gt; [ &quot;user_name = ?&quot;, user_name])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line586">586</a>       #   Person.find(:last, :order =&gt; &quot;created_on DESC&quot;, :offset =&gt; 5)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line587">587</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line588">588</a>       #   # find all</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line589">589</a>       #   Person.find(:all) # returns an array of objects for all the rows fetched by SELECT * FROM people</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line590">590</a>       #   Person.find(:all, :conditions =&gt; [ &quot;category IN (?)&quot;, categories], :limit =&gt; 50)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line591">591</a>       #   Person.find(:all, :conditions =&gt; { :friends =&gt; [&quot;Bob&quot;, &quot;Steve&quot;, &quot;Fred&quot;] }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line592">592</a>       #   Person.find(:all, :offset =&gt; 10, :limit =&gt; 10)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line593">593</a>       #   Person.find(:all, :include =&gt; [ :account, :friends ])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line594">594</a>       #   Person.find(:all, :group =&gt; &quot;category&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line595">595</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line596">596</a>       # Example for find with a lock: Imagine two concurrent transactions:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line597">597</a>       # each will read &lt;tt&gt;person.visits == 2&lt;/tt&gt;, add 1 to it, and save, resulting</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line598">598</a>       # in two saves of &lt;tt&gt;person.visits = 3&lt;/tt&gt;.  By locking the row, the second</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line599">599</a>       # transaction has to wait until the first is finished; we get the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line600">600</a>       # expected &lt;tt&gt;person.visits == 4&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line601">601</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line602">602</a>       #   Person.transaction do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line603">603</a>       #     person = Person.find(1, :lock =&gt; true)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line604">604</a>       #     person.visits += 1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line605">605</a>       #     person.save!</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line606">606</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line607">607</a>       def find(*args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line608">608</a>         options = args.extract_options!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line609">609</a>         validate_find_options(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line610">610</a>         set_readonly_option!(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line611">611</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line612">612</a>         case args.first</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line613">613</a>           when :first then find_initial(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line614">614</a>           when :last  then find_last(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line615">615</a>           when :all   then find_every(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line616">616</a>           else             find_from_ids(args, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line617">617</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line618">618</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line619">619</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line620">620</a>       # A convenience wrapper for &lt;tt&gt;find(:first, *args)&lt;/tt&gt;. You can pass in all the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line621">621</a>       # same arguments to this method as you can to &lt;tt&gt;find(:first)&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line622">622</a>       def first(*args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line623">623</a>         find(:first, *args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line624">624</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line625">625</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line626">626</a>       # A convenience wrapper for &lt;tt&gt;find(:last, *args)&lt;/tt&gt;. You can pass in all the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line627">627</a>       # same arguments to this method as you can to &lt;tt&gt;find(:last)&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line628">628</a>       def last(*args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line629">629</a>         find(:last, *args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line630">630</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line631">631</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line632">632</a>       # This is an alias for find(:all).  You can pass in all the same arguments to this method as you can</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line633">633</a>       # to find(:all)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line634">634</a>       def all(*args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line635">635</a>         find(:all, *args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line636">636</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line637">637</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line638">638</a>       # Executes a custom SQL query against your database and returns all the results.  The results will</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line639">639</a>       # be returned as an array with columns requested encapsulated as attributes of the model you call</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line640">640</a>       # this method from.  If you call &lt;tt&gt;Product.find_by_sql&lt;/tt&gt; then the results will be returned in</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line641">641</a>       # a Product object with the attributes you specified in the SQL query.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line642">642</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line643">643</a>       # If you call a complicated SQL query which spans multiple tables the columns specified by the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line644">644</a>       # SELECT will be attributes of the model, whether or not they are columns of the corresponding</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line645">645</a>       # table.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line646">646</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line647">647</a>       # The +sql+ parameter is a full SQL query as a string.  It will be called as is, there will be</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line648">648</a>       # no database agnostic conversions performed.  This should be a last resort because using, for example,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line649">649</a>       # MySQL specific terms will lock you to using that particular database engine or require you to</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line650">650</a>       # change your call if you switch engines.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line651">651</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line652">652</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line653">653</a>       #   # A simple SQL query spanning multiple tables</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line654">654</a>       #   Post.find_by_sql &quot;SELECT p.title, c.author FROM posts p, comments c WHERE p.id = c.post_id&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line655">655</a>       #   &gt; [#&lt;Post:0x36bff9c @attributes={&quot;title&quot;=&gt;&quot;Ruby Meetup&quot;, &quot;first_name&quot;=&gt;&quot;Quentin&quot;}&gt;, ...]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line656">656</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line657">657</a>       #   # You can use the same string replacement techniques as you can with ActiveRecord#find</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line658">658</a>       #   Post.find_by_sql [&quot;SELECT title FROM posts WHERE author = ? AND created &gt; ?&quot;, author_id, start_date]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line659">659</a>       #   &gt; [#&lt;Post:0x36bff9c @attributes={&quot;first_name&quot;=&gt;&quot;The Cheap Man Buys Twice&quot;}&gt;, ...]</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line660">660</a>       def find_by_sql(sql)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line661">661</a>         connection.select_all(sanitize_sql(sql), &quot;#{name} Load&quot;).collect! { |record| instantiate(record) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line662">662</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line663">663</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line664">664</a>       # Returns true if a record exists in the table that matches the +id+ or</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line665">665</a>       # conditions given, or false otherwise. The argument can take five forms:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line666">666</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line667">667</a>       # * Integer - Finds the record with this primary key.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line668">668</a>       # * String - Finds the record with a primary key corresponding to this</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line669">669</a>       #   string (such as &lt;tt&gt;'5'&lt;/tt&gt;).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line670">670</a>       # * Array - Finds the record that matches these +find+-style conditions</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line671">671</a>       #   (such as &lt;tt&gt;['color = ?', 'red']&lt;/tt&gt;).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line672">672</a>       # * Hash - Finds the record that matches these +find+-style conditions</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line673">673</a>       #   (such as &lt;tt&gt;{:color =&gt; 'red'}&lt;/tt&gt;).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line674">674</a>       # * No args - Returns false if the table is empty, true otherwise.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line675">675</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line676">676</a>       # For more information about specifying conditions as a Hash or Array,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line677">677</a>       # see the Conditions section in the introduction to ActiveRecord::Base.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line678">678</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line679">679</a>       # Note: You can't pass in a condition as a string (like &lt;tt&gt;name =</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line680">680</a>       # 'Jamie'&lt;/tt&gt;), since it would be sanitized and then queried against</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line681">681</a>       # the primary key column, like &lt;tt&gt;id = 'name = \'Jamie\''&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line682">682</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line683">683</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line684">684</a>       #   Person.exists?(5)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line685">685</a>       #   Person.exists?('5')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line686">686</a>       #   Person.exists?(:name =&gt; &quot;David&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line687">687</a>       #   Person.exists?(['name LIKE ?', &quot;%#{query}%&quot;])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line688">688</a>       #   Person.exists?</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line689">689</a>       def exists?(id_or_conditions = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line690">690</a>         find_initial(</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line691">691</a>           :select =&gt; &quot;#{quoted_table_name}.#{primary_key}&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line692">692</a>           :conditions =&gt; expand_id_conditions(id_or_conditions)) ? true : false</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line693">693</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line694">694</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line695">695</a>       # Creates an object (or multiple objects) and saves it to the database, if validations pass.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line696">696</a>       # The resulting object is returned whether the object was saved successfully to the database or not.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line697">697</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line698">698</a>       # The +attributes+ parameter can be either be a Hash or an Array of Hashes.  These Hashes describe the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line699">699</a>       # attributes on the objects that are to be created.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line700">700</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line701">701</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line702">702</a>       #   # Create a single new object</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line703">703</a>       #   User.create(:first_name =&gt; 'Jamie')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line704">704</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line705">705</a>       #   # Create an Array of new objects</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line706">706</a>       #   User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line707">707</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line708">708</a>       #   # Create a single object and pass it into a block to set other attributes.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line709">709</a>       #   User.create(:first_name =&gt; 'Jamie') do |u|</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line710">710</a>       #     u.is_admin = false</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line711">711</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line712">712</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line713">713</a>       #   # Creating an Array of new objects using a block, where the block is executed for each object:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line714">714</a>       #   User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }]) do |u|</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line715">715</a>       #     u.is_admin = false</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line716">716</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line717">717</a>       def create(attributes = nil, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line718">718</a>         if attributes.is_a?(Array)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line719">719</a>           attributes.collect { |attr| create(attr, &amp;block) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line720">720</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line721">721</a>           object = new(attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line722">722</a>           yield(object) if block_given?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line723">723</a>           object.save</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line724">724</a>           object</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line725">725</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line726">726</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line727">727</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line728">728</a>       # Updates an object (or multiple objects) and saves it to the database, if validations pass.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line729">729</a>       # The resulting object is returned whether the object was saved successfully to the database or not.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line730">730</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line731">731</a>       # ==== Parameters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line732">732</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line733">733</a>       # * +id+ - This should be the id or an array of ids to be updated.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line734">734</a>       # * +attributes+ - This should be a hash of attributes to be set on the object, or an array of hashes.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line735">735</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line736">736</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line737">737</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line738">738</a>       #   # Updating one record:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line739">739</a>       #   Person.update(15, :user_name =&gt; 'Samuel', :group =&gt; 'expert')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line740">740</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line741">741</a>       #   # Updating multiple records:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line742">742</a>       #   people = { 1 =&gt; { &quot;first_name&quot; =&gt; &quot;David&quot; }, 2 =&gt; { &quot;first_name&quot; =&gt; &quot;Jeremy&quot; } }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line743">743</a>       #   Person.update(people.keys, people.values)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line744">744</a>       def update(id, attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line745">745</a>         if id.is_a?(Array)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line746">746</a>           idx = -1</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line747">747</a>           id.collect { |one_id| idx += 1; update(one_id, attributes[idx]) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line748">748</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line749">749</a>           object = find(id)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line750">750</a>           object.update_attributes(attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line751">751</a>           object</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line752">752</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line753">753</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line754">754</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line755">755</a>       # Deletes the row with a primary key matching the +id+ argument, using a</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line756">756</a>       # SQL +DELETE+ statement, and returns the number of rows deleted. Active</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line757">757</a>       # Record objects are not instantiated, so the object's callbacks are not</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line758">758</a>       # executed, including any &lt;tt&gt;:dependent&lt;/tt&gt; association options or</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line759">759</a>       # Observer methods.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line760">760</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line761">761</a>       # You can delete multiple rows at once by passing an Array of &lt;tt&gt;id&lt;/tt&gt;s.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line762">762</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line763">763</a>       # Note: Although it is often much faster than the alternative,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line764">764</a>       # &lt;tt&gt;#destroy&lt;/tt&gt;, skipping callbacks might bypass business logic in</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line765">765</a>       # your application that ensures referential integrity or performs other</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line766">766</a>       # essential jobs.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line767">767</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line768">768</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line769">769</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line770">770</a>       #   # Delete a single row</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line771">771</a>       #   Todo.delete(1)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line772">772</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line773">773</a>       #   # Delete multiple rows</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line774">774</a>       #   Todo.delete([2,3,4])</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line775">775</a>       def delete(id)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line776">776</a>         delete_all([ &quot;#{connection.quote_column_name(primary_key)} IN (?)&quot;, id ])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line777">777</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line778">778</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line779">779</a>       # Destroy an object (or multiple objects) that has the given id, the object is instantiated first,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line780">780</a>       # therefore all callbacks and filters are fired off before the object is deleted.  This method is</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line781">781</a>       # less efficient than ActiveRecord#delete but allows cleanup methods and other actions to be run.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line782">782</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line783">783</a>       # This essentially finds the object (or multiple objects) with the given id, creates a new object</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line784">784</a>       # from the attributes, and then calls destroy on it.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line785">785</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line786">786</a>       # ==== Parameters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line787">787</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line788">788</a>       # * +id+ - Can be either an Integer or an Array of Integers.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line789">789</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line790">790</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line791">791</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line792">792</a>       #   # Destroy a single object</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line793">793</a>       #   Todo.destroy(1)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line794">794</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line795">795</a>       #   # Destroy multiple objects</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line796">796</a>       #   todos = [1,2,3]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line797">797</a>       #   Todo.destroy(todos)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line798">798</a>       def destroy(id)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line799">799</a>         if id.is_a?(Array)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line800">800</a>           id.map { |one_id| destroy(one_id) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line801">801</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line802">802</a>           find(id).destroy</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line803">803</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line804">804</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line805">805</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line806">806</a>       # Updates all records with details given if they match a set of conditions supplied, limits and order can</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line807">807</a>       # also be supplied. This method constructs a single SQL UPDATE statement and sends it straight to the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line808">808</a>       # database. It does not instantiate the involved models and it does not trigger Active Record callbacks.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line809">809</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line810">810</a>       # ==== Parameters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line811">811</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line812">812</a>       # * +updates+ - A string of column and value pairs that will be set on any records that match conditions. This creates the SET clause of the generated SQL.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line813">813</a>       # * +conditions+ - An SQL fragment like &quot;administrator = 1&quot; or [ &quot;user_name = ?&quot;, username ]. See conditions in the intro for more info.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line814">814</a>       # * +options+ - Additional options are &lt;tt&gt;:limit&lt;/tt&gt; and &lt;tt&gt;:order&lt;/tt&gt;, see the examples for usage.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line815">815</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line816">816</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line817">817</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line818">818</a>       #   # Update all billing objects with the 3 different attributes given</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line819">819</a>       #   Billing.update_all( &quot;category = 'authorized', approved = 1, author = 'David'&quot; )</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line820">820</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line821">821</a>       #   # Update records that match our conditions</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line822">822</a>       #   Billing.update_all( &quot;author = 'David'&quot;, &quot;title LIKE '%Rails%'&quot; )</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line823">823</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line824">824</a>       #   # Update records that match our conditions but limit it to 5 ordered by date</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line825">825</a>       #   Billing.update_all( &quot;author = 'David'&quot;, &quot;title LIKE '%Rails%'&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line826">826</a>       #                         :order =&gt; 'created_at', :limit =&gt; 5 )</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line827">827</a>       def update_all(updates, conditions = nil, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line828">828</a>         sql  = &quot;UPDATE #{quoted_table_name} SET #{sanitize_sql_for_assignment(updates)} &quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line829">829</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line830">830</a>         scope = scope(:find)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line831">831</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line832">832</a>         select_sql = &quot;&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line833">833</a>         add_conditions!(select_sql, conditions, scope)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line834">834</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line835">835</a>         if options.has_key?(:limit) || (scope &amp;&amp; scope[:limit])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line836">836</a>           # Only take order from scope if limit is also provided by scope, this</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line837">837</a>           # is useful for updating a has_many association with a limit.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line838">838</a>           add_order!(select_sql, options[:order], scope)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line839">839</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line840">840</a>           add_limit!(select_sql, options, scope)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line841">841</a>           sql.concat(connection.limited_update_conditions(select_sql, quoted_table_name, connection.quote_column_name(primary_key)))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line842">842</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line843">843</a>           add_order!(select_sql, options[:order], nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line844">844</a>           sql.concat(select_sql)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line845">845</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line846">846</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line847">847</a>         connection.update(sql, &quot;#{name} Update&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line848">848</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line849">849</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line850">850</a>       # Destroys the records matching +conditions+ by instantiating each</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line851">851</a>       # record and calling its +destroy+ method. Each object's callbacks are</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line852">852</a>       # executed (including &lt;tt&gt;:dependent&lt;/tt&gt; association options and</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line853">853</a>       # +before_destroy+/+after_destroy+ Observer methods). Returns the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line854">854</a>       # collection of objects that were destroyed; each will be frozen, to</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line855">855</a>       # reflect that no changes should be made (since they can't be</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line856">856</a>       # persisted).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line857">857</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line858">858</a>       # Note: Instantiation, callback execution, and deletion of each</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line859">859</a>       # record can be time consuming when you're removing many records at</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line860">860</a>       # once. It generates at least one SQL +DELETE+ query per record (or</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line861">861</a>       # possibly more, to enforce your callbacks). If you want to delete many</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line862">862</a>       # rows quickly, without concern for their associations or callbacks, use</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line863">863</a>       # +delete_all+ instead.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line864">864</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line865">865</a>       # ==== Parameters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line866">866</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line867">867</a>       # * +conditions+ - A string, array, or hash that specifies which records</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line868">868</a>       #   to destroy. If omitted, all records are destroyed. See the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line869">869</a>       #   Conditions section in the introduction to ActiveRecord::Base for</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line870">870</a>       #   more information.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line871">871</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line872">872</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line873">873</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line874">874</a>       #   Person.destroy_all(&quot;last_login &lt; '2004-04-04'&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line875">875</a>       #   Person.destroy_all(:status =&gt; &quot;inactive&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line876">876</a>       def destroy_all(conditions = nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line877">877</a>         find(:all, :conditions =&gt; conditions).each { |object| object.destroy }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line878">878</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line879">879</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line880">880</a>       # Deletes the records matching +conditions+ without instantiating the records first, and hence not</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line881">881</a>       # calling the +destroy+ method nor invoking callbacks. This is a single SQL DELETE statement that</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line882">882</a>       # goes straight to the database, much more efficient than +destroy_all+. Be careful with relations</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line883">883</a>       # though, in particular &lt;tt&gt;:dependent&lt;/tt&gt; rules defined on associations are not honored.  Returns</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line884">884</a>       # the number of rows affected.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line885">885</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line886">886</a>       # ==== Parameters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line887">887</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line888">888</a>       # * +conditions+ - Conditions are specified the same way as with +find+ method.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line889">889</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line890">890</a>       # ==== Example</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line891">891</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line892">892</a>       #   Post.delete_all(&quot;person_id = 5 AND (category = 'Something' OR category = 'Else')&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line893">893</a>       #   Post.delete_all([&quot;person_id = ? AND (category = ? OR category = ?)&quot;, 5, 'Something', 'Else'])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line894">894</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line895">895</a>       # Both calls delete the affected posts all at once with a single DELETE statement. If you need to destroy dependent</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line896">896</a>       # associations or call your &lt;tt&gt;before_*&lt;/tt&gt; or +after_destroy+ callbacks, use the +destroy_all+ method instead.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line897">897</a>       def delete_all(conditions = nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line898">898</a>         sql = &quot;DELETE FROM #{quoted_table_name} &quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line899">899</a>         add_conditions!(sql, conditions, scope(:find))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line900">900</a>         connection.delete(sql, &quot;#{name} Delete all&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line901">901</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line902">902</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line903">903</a>       # Returns the result of an SQL statement that should only include a COUNT(*) in the SELECT part.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line904">904</a>       # The use of this method should be restricted to complicated SQL queries that can't be executed</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line905">905</a>       # using the ActiveRecord::Calculations class methods.  Look into those before using this.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line906">906</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line907">907</a>       # ==== Parameters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line908">908</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line909">909</a>       # * +sql+ - An SQL statement which should return a count query from the database, see the example below.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line910">910</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line911">911</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line912">912</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line913">913</a>       #   Product.count_by_sql &quot;SELECT COUNT(*) FROM sales s, customers c WHERE s.customer_id = c.id&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line914">914</a>       def count_by_sql(sql)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line915">915</a>         sql = sanitize_conditions(sql)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line916">916</a>         connection.select_value(sql, &quot;#{name} Count&quot;).to_i</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line917">917</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line918">918</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line919">919</a>       # A generic &quot;counter updater&quot; implementation, intended primarily to be</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line920">920</a>       # used by increment_counter and decrement_counter, but which may also</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line921">921</a>       # be useful on its own. It simply does a direct SQL update for the record</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line922">922</a>       # with the given ID, altering the given hash of counters by the amount</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line923">923</a>       # given by the corresponding value:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line924">924</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line925">925</a>       # ==== Parameters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line926">926</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line927">927</a>       # * +id+ - The id of the object you wish to update a counter on or an Array of ids.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line928">928</a>       # * +counters+ - An Array of Hashes containing the names of the fields</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line929">929</a>       #   to update as keys and the amount to update the field by as values.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line930">930</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line931">931</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line932">932</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line933">933</a>       #   # For the Post with id of 5, decrement the comment_count by 1, and</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line934">934</a>       #   # increment the action_count by 1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line935">935</a>       #   Post.update_counters 5, :comment_count =&gt; -1, :action_count =&gt; 1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line936">936</a>       #   # Executes the following SQL:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line937">937</a>       #   # UPDATE posts</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line938">938</a>       #   #    SET comment_count = comment_count - 1,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line939">939</a>       #   #        action_count = action_count + 1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line940">940</a>       #   #  WHERE id = 5</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line941">941</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line942">942</a>       #   # For the Posts with id of 10 and 15, increment the comment_count by 1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line943">943</a>       #   Post.update_counters [10, 15], :comment_count =&gt; 1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line944">944</a>       #   # Executes the following SQL:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line945">945</a>       #   # UPDATE posts</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line946">946</a>       #   #    SET comment_count = comment_count + 1,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line947">947</a>       #   #  WHERE id IN (10, 15)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line948">948</a>       def update_counters(id, counters)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line949">949</a>         updates = counters.inject([]) { |list, (counter_name, increment)|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line950">950</a>           sign = increment &lt; 0 ? &quot;-&quot; : &quot;+&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line951">951</a>           list &lt;&lt; &quot;#{connection.quote_column_name(counter_name)} = COALESCE(#{connection.quote_column_name(counter_name)}, 0) #{sign} #{increment.abs}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line952">952</a>         }.join(&quot;, &quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line953">953</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line954">954</a>         if id.is_a?(Array)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line955">955</a>           ids_list = id.map {|i| quote_value(i)}.join(', ')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line956">956</a>           condition = &quot;IN  (#{ids_list})&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line957">957</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line958">958</a>           condition = &quot;= #{quote_value(id)}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line959">959</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line960">960</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line961">961</a>         update_all(updates, &quot;#{connection.quote_column_name(primary_key)} #{condition}&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line962">962</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line963">963</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line964">964</a>       # Increment a number field by one, usually representing a count.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line965">965</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line966">966</a>       # This is used for caching aggregate values, so that they don't need to be computed every time.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line967">967</a>       # For example, a DiscussionBoard may cache post_count and comment_count otherwise every time the board is</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line968">968</a>       # shown it would have to run an SQL query to find how many posts and comments there are.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line969">969</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line970">970</a>       # ==== Parameters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line971">971</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line972">972</a>       # * +counter_name+ - The name of the field that should be incremented.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line973">973</a>       # * +id+ - The id of the object that should be incremented.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line974">974</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line975">975</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line976">976</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line977">977</a>       #   # Increment the post_count column for the record with an id of 5</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line978">978</a>       #   DiscussionBoard.increment_counter(:post_count, 5)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line979">979</a>       def increment_counter(counter_name, id)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line980">980</a>         update_counters(id, counter_name =&gt; 1)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line981">981</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line982">982</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line983">983</a>       # Decrement a number field by one, usually representing a count.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line984">984</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line985">985</a>       # This works the same as increment_counter but reduces the column value by 1 instead of increasing it.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line986">986</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line987">987</a>       # ==== Parameters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line988">988</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line989">989</a>       # * +counter_name+ - The name of the field that should be decremented.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line990">990</a>       # * +id+ - The id of the object that should be decremented.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line991">991</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line992">992</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line993">993</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line994">994</a>       #   # Decrement the post_count column for the record with an id of 5</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line995">995</a>       #   DiscussionBoard.decrement_counter(:post_count, 5)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line996">996</a>       def decrement_counter(counter_name, id)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line997">997</a>         update_counters(id, counter_name =&gt; -1)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line998">998</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line999">999</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1000">1000</a>       # Attributes named in this macro are protected from mass-assignment,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1001">1001</a>       # such as &lt;tt&gt;new(attributes)&lt;/tt&gt;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1002">1002</a>       # &lt;tt&gt;update_attributes(attributes)&lt;/tt&gt;, or</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1003">1003</a>       # &lt;tt&gt;attributes=(attributes)&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1004">1004</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1005">1005</a>       # Mass-assignment to these attributes will simply be ignored, to assign</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1006">1006</a>       # to them you can use direct writer methods. This is meant to protect</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1007">1007</a>       # sensitive attributes from being overwritten by malicious users</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1008">1008</a>       # tampering with URLs or forms.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1009">1009</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1010">1010</a>       #   class Customer &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1011">1011</a>       #     attr_protected :credit_rating</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1012">1012</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1013">1013</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1014">1014</a>       #   customer = Customer.new(&quot;name&quot; =&gt; David, &quot;credit_rating&quot; =&gt; &quot;Excellent&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1015">1015</a>       #   customer.credit_rating # =&gt; nil</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1016">1016</a>       #   customer.attributes = { &quot;description&quot; =&gt; &quot;Jolly fellow&quot;, &quot;credit_rating&quot; =&gt; &quot;Superb&quot; }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1017">1017</a>       #   customer.credit_rating # =&gt; nil</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1018">1018</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1019">1019</a>       #   customer.credit_rating = &quot;Average&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1020">1020</a>       #   customer.credit_rating # =&gt; &quot;Average&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1021">1021</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1022">1022</a>       # To start from an all-closed default and enable attributes as needed,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1023">1023</a>       # have a look at +attr_accessible+.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1024">1024</a>       def attr_protected(*attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1025">1025</a>         write_inheritable_attribute(:attr_protected, Set.new(attributes.map(&amp;:to_s)) + (protected_attributes || []))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1026">1026</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1027">1027</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1028">1028</a>       # Returns an array of all the attributes that have been protected from mass-assignment.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1029">1029</a>       def protected_attributes # :nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1030">1030</a>         read_inheritable_attribute(:attr_protected)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1031">1031</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1032">1032</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1033">1033</a>       # Specifies a white list of model attributes that can be set via</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1034">1034</a>       # mass-assignment, such as &lt;tt&gt;new(attributes)&lt;/tt&gt;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1035">1035</a>       # &lt;tt&gt;update_attributes(attributes)&lt;/tt&gt;, or</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1036">1036</a>       # &lt;tt&gt;attributes=(attributes)&lt;/tt&gt;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1037">1037</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1038">1038</a>       # This is the opposite of the +attr_protected+ macro: Mass-assignment</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1039">1039</a>       # will only set attributes in this list, to assign to the rest of</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1040">1040</a>       # attributes you can use direct writer methods. This is meant to protect</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1041">1041</a>       # sensitive attributes from being overwritten by malicious users</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1042">1042</a>       # tampering with URLs or forms. If you'd rather start from an all-open</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1043">1043</a>       # default and restrict attributes as needed, have a look at</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1044">1044</a>       # +attr_protected+.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1045">1045</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1046">1046</a>       #   class Customer &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1047">1047</a>       #     attr_accessible :name, :nickname</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1048">1048</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1049">1049</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1050">1050</a>       #   customer = Customer.new(:name =&gt; &quot;David&quot;, :nickname =&gt; &quot;Dave&quot;, :credit_rating =&gt; &quot;Excellent&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1051">1051</a>       #   customer.credit_rating # =&gt; nil</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1052">1052</a>       #   customer.attributes = { :name =&gt; &quot;Jolly fellow&quot;, :credit_rating =&gt; &quot;Superb&quot; }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1053">1053</a>       #   customer.credit_rating # =&gt; nil</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1054">1054</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1055">1055</a>       #   customer.credit_rating = &quot;Average&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1056">1056</a>       #   customer.credit_rating # =&gt; &quot;Average&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1057">1057</a>       def attr_accessible(*attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1058">1058</a>         write_inheritable_attribute(:attr_accessible, Set.new(attributes.map(&amp;:to_s)) + (accessible_attributes || []))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1059">1059</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1060">1060</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1061">1061</a>       # Returns an array of all the attributes that have been made accessible to mass-assignment.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1062">1062</a>       def accessible_attributes # :nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1063">1063</a>         read_inheritable_attribute(:attr_accessible)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1064">1064</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1065">1065</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1066">1066</a>        # Attributes listed as readonly can be set for a new record, but will be ignored in database updates afterwards.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1067">1067</a>        def attr_readonly(*attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1068">1068</a>          write_inheritable_attribute(:attr_readonly, Set.new(attributes.map(&amp;:to_s)) + (readonly_attributes || []))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1069">1069</a>        end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1070">1070</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1071">1071</a>        # Returns an array of all the attributes that have been specified as readonly.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1072">1072</a>        def readonly_attributes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1073">1073</a>          read_inheritable_attribute(:attr_readonly)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1074">1074</a>        end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1075">1075</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1076">1076</a>       # If you have an attribute that needs to be saved to the database as an object, and retrieved as the same object,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1077">1077</a>       # then specify the name of that attribute using this method and it will be handled automatically.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1078">1078</a>       # The serialization is done through YAML. If +class_name+ is specified, the serialized object must be of that</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1079">1079</a>       # class on retrieval or SerializationTypeMismatch will be raised.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1080">1080</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1081">1081</a>       # ==== Parameters</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1082">1082</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1083">1083</a>       # * +attr_name+ - The field name that should be serialized.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1084">1084</a>       # * +class_name+ - Optional, class name that the object type should be equal to.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1085">1085</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1086">1086</a>       # ==== Example</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1087">1087</a>       #   # Serialize a preferences attribute</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1088">1088</a>       #   class User</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1089">1089</a>       #     serialize :preferences</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1090">1090</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1091">1091</a>       def serialize(attr_name, class_name = Object)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1092">1092</a>         serialized_attributes[attr_name.to_s] = class_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1093">1093</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1094">1094</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1095">1095</a>       # Returns a hash of all the attributes that have been specified for serialization as keys and their class restriction as values.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1096">1096</a>       def serialized_attributes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1097">1097</a>         read_inheritable_attribute(:attr_serialized) or write_inheritable_attribute(:attr_serialized, {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1098">1098</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1099">1099</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1100">1100</a>       # Guesses the table name (in forced lower-case) based on the name of the class in the inheritance hierarchy descending</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1101">1101</a>       # directly from ActiveRecord::Base. So if the hierarchy looks like: Reply &lt; Message &lt; ActiveRecord::Base, then Message is used</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1102">1102</a>       # to guess the table name even when called on Reply. The rules used to do the guess are handled by the Inflector class</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1103">1103</a>       # in Active Support, which knows almost all common English inflections. You can add new inflections in config/initializers/inflections.rb.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1104">1104</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1105">1105</a>       # Nested classes are given table names prefixed by the singular form of</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1106">1106</a>       # the parent's table name. Enclosing modules are not considered.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1107">1107</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1108">1108</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1109">1109</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1110">1110</a>       #   class Invoice &lt; ActiveRecord::Base; end;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1111">1111</a>       #   file                  class               table_name</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1112">1112</a>       #   invoice.rb            Invoice             invoices</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1113">1113</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1114">1114</a>       #   class Invoice &lt; ActiveRecord::Base; class Lineitem &lt; ActiveRecord::Base; end; end;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1115">1115</a>       #   file                  class               table_name</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1116">1116</a>       #   invoice.rb            Invoice::Lineitem   invoice_lineitems</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1117">1117</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1118">1118</a>       #   module Invoice; class Lineitem &lt; ActiveRecord::Base; end; end;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1119">1119</a>       #   file                  class               table_name</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1120">1120</a>       #   invoice/lineitem.rb   Invoice::Lineitem   lineitems</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1121">1121</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1122">1122</a>       # Additionally, the class-level +table_name_prefix+ is prepended and the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1123">1123</a>       # +table_name_suffix+ is appended.  So if you have &quot;myapp_&quot; as a prefix,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1124">1124</a>       # the table name guess for an Invoice class becomes &quot;myapp_invoices&quot;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1125">1125</a>       # Invoice::Lineitem becomes &quot;myapp_invoice_lineitems&quot;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1126">1126</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1127">1127</a>       # You can also overwrite this class method to allow for unguessable</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1128">1128</a>       # links, such as a Mouse class with a link to a &quot;mice&quot; table. Example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1129">1129</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1130">1130</a>       #   class Mouse &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1131">1131</a>       #     set_table_name &quot;mice&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1132">1132</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1133">1133</a>       def table_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1134">1134</a>         reset_table_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1135">1135</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1136">1136</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1137">1137</a>       def reset_table_name #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1138">1138</a>         base = base_class</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1139">1139</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1140">1140</a>         name =</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1141">1141</a>           # STI subclasses always use their superclass' table.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1142">1142</a>           unless self == base</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1143">1143</a>             base.table_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1144">1144</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1145">1145</a>             # Nested classes are prefixed with singular parent table name.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1146">1146</a>             if parent &lt; ActiveRecord::Base &amp;&amp; !parent.abstract_class?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1147">1147</a>               contained = parent.table_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1148">1148</a>               contained = contained.singularize if parent.pluralize_table_names</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1149">1149</a>               contained &lt;&lt; '_'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1150">1150</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1151">1151</a>             name = &quot;#{table_name_prefix}#{contained}#{undecorated_table_name(base.name)}#{table_name_suffix}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1152">1152</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1153">1153</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1154">1154</a>         set_table_name(name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1155">1155</a>         name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1156">1156</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1157">1157</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1158">1158</a>       # Defines the primary key field -- can be overridden in subclasses. Overwriting will negate any effect of the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1159">1159</a>       # primary_key_prefix_type setting, though.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1160">1160</a>       def primary_key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1161">1161</a>         reset_primary_key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1162">1162</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1163">1163</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1164">1164</a>       def reset_primary_key #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1165">1165</a>         key = get_primary_key(base_class.name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1166">1166</a>         set_primary_key(key)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1167">1167</a>         key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1168">1168</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1169">1169</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1170">1170</a>       def get_primary_key(base_name) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1171">1171</a>         key = 'id'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1172">1172</a>         case primary_key_prefix_type</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1173">1173</a>           when :table_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1174">1174</a>             key = base_name.to_s.foreign_key(false)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1175">1175</a>           when :table_name_with_underscore</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1176">1176</a>             key = base_name.to_s.foreign_key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1177">1177</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1178">1178</a>         key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1179">1179</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1180">1180</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1181">1181</a>       # Defines the column name for use with single table inheritance</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1182">1182</a>       # -- can be set in subclasses like so: self.inheritance_column = &quot;type_id&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1183">1183</a>       def inheritance_column</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1184">1184</a>         @inheritance_column ||= &quot;type&quot;.freeze</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1185">1185</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1186">1186</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1187">1187</a>       # Lazy-set the sequence name to the connection's default.  This method</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1188">1188</a>       # is only ever called once since set_sequence_name overrides it.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1189">1189</a>       def sequence_name #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1190">1190</a>         reset_sequence_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1191">1191</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1192">1192</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1193">1193</a>       def reset_sequence_name #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1194">1194</a>         default = connection.default_sequence_name(table_name, primary_key)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1195">1195</a>         set_sequence_name(default)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1196">1196</a>         default</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1197">1197</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1198">1198</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1199">1199</a>       # Sets the table name to use to the given value, or (if the value</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1200">1200</a>       # is nil or false) to the value returned by the given block.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1201">1201</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1202">1202</a>       #   class Project &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1203">1203</a>       #     set_table_name &quot;project&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1204">1204</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1205">1205</a>       def set_table_name(value = nil, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1206">1206</a>         define_attr_method :table_name, value, &amp;block</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1207">1207</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1208">1208</a>       alias :table_name= :set_table_name</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1209">1209</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1210">1210</a>       # Sets the name of the primary key column to use to the given value,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1211">1211</a>       # or (if the value is nil or false) to the value returned by the given</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1212">1212</a>       # block.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1213">1213</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1214">1214</a>       #   class Project &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1215">1215</a>       #     set_primary_key &quot;sysid&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1216">1216</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1217">1217</a>       def set_primary_key(value = nil, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1218">1218</a>         define_attr_method :primary_key, value, &amp;block</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1219">1219</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1220">1220</a>       alias :primary_key= :set_primary_key</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1221">1221</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1222">1222</a>       # Sets the name of the inheritance column to use to the given value,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1223">1223</a>       # or (if the value # is nil or false) to the value returned by the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1224">1224</a>       # given block.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1225">1225</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1226">1226</a>       #   class Project &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1227">1227</a>       #     set_inheritance_column do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1228">1228</a>       #       original_inheritance_column + &quot;_id&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1229">1229</a>       #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1230">1230</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1231">1231</a>       def set_inheritance_column(value = nil, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1232">1232</a>         define_attr_method :inheritance_column, value, &amp;block</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1233">1233</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1234">1234</a>       alias :inheritance_column= :set_inheritance_column</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1235">1235</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1236">1236</a>       # Sets the name of the sequence to use when generating ids to the given</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1237">1237</a>       # value, or (if the value is nil or false) to the value returned by the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1238">1238</a>       # given block. This is required for Oracle and is useful for any</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1239">1239</a>       # database which relies on sequences for primary key generation.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1240">1240</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1241">1241</a>       # If a sequence name is not explicitly set when using Oracle or Firebird,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1242">1242</a>       # it will default to the commonly used pattern of: #{table_name}_seq</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1243">1243</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1244">1244</a>       # If a sequence name is not explicitly set when using PostgreSQL, it</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1245">1245</a>       # will discover the sequence corresponding to your primary key for you.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1246">1246</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1247">1247</a>       #   class Project &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1248">1248</a>       #     set_sequence_name &quot;projectseq&quot;   # default would have been &quot;project_seq&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1249">1249</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1250">1250</a>       def set_sequence_name(value = nil, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1251">1251</a>         define_attr_method :sequence_name, value, &amp;block</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1252">1252</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1253">1253</a>       alias :sequence_name= :set_sequence_name</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1254">1254</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1255">1255</a>       # Turns the +table_name+ back into a class name following the reverse rules of +table_name+.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1256">1256</a>       def class_name(table_name = table_name) # :nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1257">1257</a>         # remove any prefix and/or suffix from the table name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1258">1258</a>         class_name = table_name[table_name_prefix.length..-(table_name_suffix.length + 1)].camelize</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1259">1259</a>         class_name = class_name.singularize if pluralize_table_names</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1260">1260</a>         class_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1261">1261</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1262">1262</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1263">1263</a>       # Indicates whether the table associated with this class exists</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1264">1264</a>       def table_exists?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1265">1265</a>         connection.table_exists?(table_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1266">1266</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1267">1267</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1268">1268</a>       # Returns an array of column objects for the table associated with this class.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1269">1269</a>       def columns</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1270">1270</a>         unless defined?(@columns) &amp;&amp; @columns</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1271">1271</a>           @columns = connection.columns(table_name, &quot;#{name} Columns&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1272">1272</a>           @columns.each { |column| column.primary = column.name == primary_key }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1273">1273</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1274">1274</a>         @columns</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1275">1275</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1276">1276</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1277">1277</a>       # Returns a hash of column objects for the table associated with this class.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1278">1278</a>       def columns_hash</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1279">1279</a>         @columns_hash ||= columns.inject({}) { |hash, column| hash[column.name] = column; hash }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1280">1280</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1281">1281</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1282">1282</a>       # Returns an array of column names as strings.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1283">1283</a>       def column_names</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1284">1284</a>         @column_names ||= columns.map { |column| column.name }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1285">1285</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1286">1286</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1287">1287</a>       # Returns an array of column objects where the primary id, all columns ending in &quot;_id&quot; or &quot;_count&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1288">1288</a>       # and columns used for single table inheritance have been removed.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1289">1289</a>       def content_columns</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1290">1290</a>         @content_columns ||= columns.reject { |c| c.primary || c.name =~ /(_id|_count)$/ || c.name == inheritance_column }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1291">1291</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1292">1292</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1293">1293</a>       # Returns a hash of all the methods added to query each of the columns in the table with the name of the method as the key</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1294">1294</a>       # and true as the value. This makes it possible to do O(1) lookups in respond_to? to check if a given method for attribute</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1295">1295</a>       # is available.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1296">1296</a>       def column_methods_hash #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1297">1297</a>         @dynamic_methods_hash ||= column_names.inject(Hash.new(false)) do |methods, attr|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1298">1298</a>           attr_name = attr.to_s</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1299">1299</a>           methods[attr.to_sym]       = attr_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1300">1300</a>           methods[&quot;#{attr}=&quot;.to_sym] = attr_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1301">1301</a>           methods[&quot;#{attr}?&quot;.to_sym] = attr_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1302">1302</a>           methods[&quot;#{attr}_before_type_cast&quot;.to_sym] = attr_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1303">1303</a>           methods</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1304">1304</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1305">1305</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1306">1306</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1307">1307</a>       # Resets all the cached information about columns, which will cause them</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1308">1308</a>       # to be reloaded on the next request.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1309">1309</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1310">1310</a>       # The most common usage pattern for this method is probably in a migration,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1311">1311</a>       # when just after creating a table you want to populate it with some default</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1312">1312</a>       # values, eg:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1313">1313</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1314">1314</a>       #  class CreateJobLevels &lt; ActiveRecord::Migration</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1315">1315</a>       #    def self.up</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1316">1316</a>       #      create_table :job_levels do |t|</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1317">1317</a>       #        t.integer :id</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1318">1318</a>       #        t.string :name</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1319">1319</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1320">1320</a>       #        t.timestamps</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1321">1321</a>       #      end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1322">1322</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1323">1323</a>       #      JobLevel.reset_column_information</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1324">1324</a>       #      %w{assistant executive manager director}.each do |type|</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1325">1325</a>       #        JobLevel.create(:name =&gt; type)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1326">1326</a>       #      end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1327">1327</a>       #    end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1328">1328</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1329">1329</a>       #    def self.down</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1330">1330</a>       #      drop_table :job_levels</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1331">1331</a>       #    end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1332">1332</a>       #  end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1333">1333</a>       def reset_column_information</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1334">1334</a>         generated_methods.each { |name| undef_method(name) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1335">1335</a>         @column_names = @columns = @columns_hash = @content_columns = @dynamic_methods_hash = @generated_methods = @inheritance_column = nil</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1336">1336</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1337">1337</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1338">1338</a>       def reset_column_information_and_inheritable_attributes_for_all_subclasses#:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1339">1339</a>         subclasses.each { |klass| klass.reset_inheritable_attributes; klass.reset_column_information }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1340">1340</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1341">1341</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1342">1342</a>       def self_and_descendants_from_active_record#nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1343">1343</a>         klass = self</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1344">1344</a>         classes = [klass]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1345">1345</a>         while klass != klass.base_class  </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1346">1346</a>           classes &lt;&lt; klass = klass.superclass</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1347">1347</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1348">1348</a>         classes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1349">1349</a>       rescue</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1350">1350</a>         # OPTIMIZE this rescue is to fix this test: ./test/cases/reflection_test.rb:56:in `test_human_name_for_column'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1351">1351</a>         # Appearantly the method base_class causes some trouble.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1352">1352</a>         # It now works for sure.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1353">1353</a>         [self]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1354">1354</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1355">1355</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1356">1356</a>       # Transforms attribute key names into a more humane format, such as &quot;First name&quot; instead of &quot;first_name&quot;. Example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1357">1357</a>       #   Person.human_attribute_name(&quot;first_name&quot;) # =&gt; &quot;First name&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1358">1358</a>       # This used to be depricated in favor of humanize, but is now preferred, because it automatically uses the I18n</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1359">1359</a>       # module now.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1360">1360</a>       # Specify +options+ with additional translating options.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1361">1361</a>       def human_attribute_name(attribute_key_name, options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1362">1362</a>         defaults = self_and_descendants_from_active_record.map do |klass|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1363">1363</a>           :&quot;#{klass.name.underscore}.#{attribute_key_name}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1364">1364</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1365">1365</a>         defaults &lt;&lt; options[:default] if options[:default]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1366">1366</a>         defaults.flatten!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1367">1367</a>         defaults &lt;&lt; attribute_key_name.humanize</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1368">1368</a>         options[:count] ||= 1</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1369">1369</a>         I18n.translate(defaults.shift, options.merge(:default =&gt; defaults, :scope =&gt; [:activerecord, :attributes]))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1370">1370</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1371">1371</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1372">1372</a>       # Transform the modelname into a more humane format, using I18n.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1373">1373</a>       # Defaults to the basic humanize method.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1374">1374</a>       # Default scope of the translation is activerecord.models</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1375">1375</a>       # Specify +options+ with additional translating options.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1376">1376</a>       def human_name(options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1377">1377</a>         defaults = self_and_descendants_from_active_record.map do |klass|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1378">1378</a>           :&quot;#{klass.name.underscore}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1379">1379</a>         end </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1380">1380</a>         defaults &lt;&lt; self.name.humanize</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1381">1381</a>         I18n.translate(defaults.shift, {:scope =&gt; [:activerecord, :models], :count =&gt; 1, :default =&gt; defaults}.merge(options))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1382">1382</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1383">1383</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1384">1384</a>       # True if this isn't a concrete subclass needing a STI type condition.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1385">1385</a>       def descends_from_active_record?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1386">1386</a>         if superclass.abstract_class?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1387">1387</a>           superclass.descends_from_active_record?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1388">1388</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1389">1389</a>           superclass == Base || !columns_hash.include?(inheritance_column)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1390">1390</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1391">1391</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1392">1392</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1393">1393</a>       def finder_needs_type_condition? #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1394">1394</a>         # This is like this because benchmarking justifies the strange :false stuff</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1395">1395</a>         :true == (@finder_needs_type_condition ||= descends_from_active_record? ? :false : :true)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1396">1396</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1397">1397</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1398">1398</a>       # Returns a string like 'Post id:integer, title:string, body:text'</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1399">1399</a>       def inspect</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1400">1400</a>         if self == Base</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1401">1401</a>           super</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1402">1402</a>         elsif abstract_class?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1403">1403</a>           &quot;#{super}(abstract)&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1404">1404</a>         elsif table_exists?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1405">1405</a>           attr_list = columns.map { |c| &quot;#{c.name}: #{c.type}&quot; } * ', '</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1406">1406</a>           &quot;#{super}(#{attr_list})&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1407">1407</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1408">1408</a>           &quot;#{super}(Table doesn't exist)&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1409">1409</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1410">1410</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1411">1411</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1412">1412</a>       def quote_value(value, column = nil) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1413">1413</a>         connection.quote(value,column)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1414">1414</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1415">1415</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1416">1416</a>       # Used to sanitize objects before they're used in an SQL SELECT statement. Delegates to &lt;tt&gt;connection.quote&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1417">1417</a>       def sanitize(object) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1418">1418</a>         connection.quote(object)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1419">1419</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1420">1420</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1421">1421</a>       # Log and benchmark multiple statements in a single block. Example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1422">1422</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1423">1423</a>       #   Project.benchmark(&quot;Creating project&quot;) do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1424">1424</a>       #     project = Project.create(&quot;name&quot; =&gt; &quot;stuff&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1425">1425</a>       #     project.create_manager(&quot;name&quot; =&gt; &quot;David&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1426">1426</a>       #     project.milestones &lt;&lt; Milestone.find(:all)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1427">1427</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1428">1428</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1429">1429</a>       # The benchmark is only recorded if the current level of the logger is less than or equal to the &lt;tt&gt;log_level&lt;/tt&gt;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1430">1430</a>       # which makes it easy to include benchmarking statements in production software that will remain inexpensive because</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1431">1431</a>       # the benchmark will only be conducted if the log level is low enough.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1432">1432</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1433">1433</a>       # The logging of the multiple statements is turned off unless &lt;tt&gt;use_silence&lt;/tt&gt; is set to false.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1434">1434</a>       def benchmark(title, log_level = Logger::DEBUG, use_silence = true)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1435">1435</a>         if logger &amp;&amp; logger.level &lt;= log_level</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1436">1436</a>           result = nil</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1437">1437</a>           ms = Benchmark.ms { result = use_silence ? silence { yield } : yield }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1438">1438</a>           logger.add(log_level, '%s (%.1fms)' % [title, ms])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1439">1439</a>           result</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1440">1440</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1441">1441</a>           yield</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1442">1442</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1443">1443</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1444">1444</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1445">1445</a>       # Silences the logger for the duration of the block.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1446">1446</a>       def silence</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1447">1447</a>         old_logger_level, logger.level = logger.level, Logger::ERROR if logger</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1448">1448</a>         yield</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1449">1449</a>       ensure</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1450">1450</a>         logger.level = old_logger_level if logger</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1451">1451</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1452">1452</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1453">1453</a>       # Overwrite the default class equality method to provide support for association proxies.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1454">1454</a>       def ===(object)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1455">1455</a>         object.is_a?(self)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1456">1456</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1457">1457</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1458">1458</a>       # Returns the base AR subclass that this class descends from. If A</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1459">1459</a>       # extends AR::Base, A.base_class will return A. If B descends from A</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1460">1460</a>       # through some arbitrarily deep hierarchy, B.base_class will return A.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1461">1461</a>       def base_class</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1462">1462</a>         class_of_active_record_descendant(self)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1463">1463</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1464">1464</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1465">1465</a>       # Set this to true if this is an abstract class (see &lt;tt&gt;abstract_class?&lt;/tt&gt;).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1466">1466</a>       attr_accessor :abstract_class</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1467">1467</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1468">1468</a>       # Returns whether this class is a base AR class.  If A is a base class and</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1469">1469</a>       # B descends from A, then B.base_class will return B.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1470">1470</a>       def abstract_class?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1471">1471</a>         defined?(@abstract_class) &amp;&amp; @abstract_class == true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1472">1472</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1473">1473</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1474">1474</a>       def respond_to?(method_id, include_private = false)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1475">1475</a>         if match = DynamicFinderMatch.match(method_id)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1476">1476</a>           return true if all_attributes_exists?(match.attribute_names)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1477">1477</a>         elsif match = DynamicScopeMatch.match(method_id)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1478">1478</a>           return true if all_attributes_exists?(match.attribute_names)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1479">1479</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1480">1480</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1481">1481</a>         super</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1482">1482</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1483">1483</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1484">1484</a>       def sti_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1485">1485</a>         store_full_sti_class ? name : name.demodulize</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1486">1486</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1487">1487</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1488">1488</a>       # Merges conditions so that the result is a valid +condition+</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1489">1489</a>       def merge_conditions(*conditions)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1490">1490</a>         segments = []</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1491">1491</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1492">1492</a>         conditions.each do |condition|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1493">1493</a>           unless condition.blank?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1494">1494</a>             sql = sanitize_sql(condition)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1495">1495</a>             segments &lt;&lt; sql unless sql.blank?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1496">1496</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1497">1497</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1498">1498</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1499">1499</a>         &quot;(#{segments.join(') AND (')})&quot; unless segments.empty?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1500">1500</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1501">1501</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1502">1502</a>       private</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1503">1503</a>         def find_initial(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1504">1504</a>           options.update(:limit =&gt; 1)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1505">1505</a>           find_every(options).first</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1506">1506</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1507">1507</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1508">1508</a>         def find_last(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1509">1509</a>           order = options[:order]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1510">1510</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1511">1511</a>           if order</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1512">1512</a>             order = reverse_sql_order(order)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1513">1513</a>           elsif !scoped?(:find, :order)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1514">1514</a>             order = &quot;#{table_name}.#{primary_key} DESC&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1515">1515</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1516">1516</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1517">1517</a>           if scoped?(:find, :order)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1518">1518</a>             scope = scope(:find)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1519">1519</a>             original_scoped_order = scope[:order]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1520">1520</a>             scope[:order] = reverse_sql_order(original_scoped_order)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1521">1521</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1522">1522</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1523">1523</a>           begin</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1524">1524</a>             find_initial(options.merge({ :order =&gt; order }))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1525">1525</a>           ensure</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1526">1526</a>             scope[:order] = original_scoped_order if original_scoped_order</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1527">1527</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1528">1528</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1529">1529</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1530">1530</a>         def reverse_sql_order(order_query)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1531">1531</a>           reversed_query = order_query.to_s.split(/,/).each { |s|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1532">1532</a>             if s.match(/\s(asc|ASC)$/)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1533">1533</a>               s.gsub!(/\s(asc|ASC)$/, ' DESC')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1534">1534</a>             elsif s.match(/\s(desc|DESC)$/)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1535">1535</a>               s.gsub!(/\s(desc|DESC)$/, ' ASC')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1536">1536</a>             elsif !s.match(/\s(asc|ASC|desc|DESC)$/)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1537">1537</a>               s.concat(' DESC')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1538">1538</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1539">1539</a>           }.join(',')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1540">1540</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1541">1541</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1542">1542</a>         def find_every(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1543">1543</a>           include_associations = merge_includes(scope(:find, :include), options[:include])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1544">1544</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1545">1545</a>           if include_associations.any? &amp;&amp; references_eager_loaded_tables?(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1546">1546</a>             records = find_with_associations(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1547">1547</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1548">1548</a>             records = find_by_sql(construct_finder_sql(options))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1549">1549</a>             if include_associations.any?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1550">1550</a>               preload_associations(records, include_associations)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1551">1551</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1552">1552</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1553">1553</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1554">1554</a>           records.each { |record| record.readonly! } if options[:readonly]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1555">1555</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1556">1556</a>           records</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1557">1557</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1558">1558</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1559">1559</a>         def find_from_ids(ids, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1560">1560</a>           expects_array = ids.first.kind_of?(Array)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1561">1561</a>           return ids.first if expects_array &amp;&amp; ids.first.empty?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1562">1562</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1563">1563</a>           ids = ids.flatten.compact.uniq</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1564">1564</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1565">1565</a>           case ids.size</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1566">1566</a>             when 0</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1567">1567</a>               raise RecordNotFound, &quot;Couldn't find #{name} without an ID&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1568">1568</a>             when 1</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1569">1569</a>               result = find_one(ids.first, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1570">1570</a>               expects_array ? [ result ] : result</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1571">1571</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1572">1572</a>               find_some(ids, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1573">1573</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1574">1574</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1575">1575</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1576">1576</a>         def find_one(id, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1577">1577</a>           conditions = &quot; AND (#{sanitize_sql(options[:conditions])})&quot; if options[:conditions]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1578">1578</a>           options.update :conditions =&gt; &quot;#{quoted_table_name}.#{connection.quote_column_name(primary_key)} = #{quote_value(id,columns_hash[primary_key])}#{conditions}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1579">1579</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1580">1580</a>           # Use find_every(options).first since the primary key condition</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1581">1581</a>           # already ensures we have a single record. Using find_initial adds</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1582">1582</a>           # a superfluous :limit =&gt; 1.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1583">1583</a>           if result = find_every(options).first</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1584">1584</a>             result</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1585">1585</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1586">1586</a>             raise RecordNotFound, &quot;Couldn't find #{name} with ID=#{id}#{conditions}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1587">1587</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1588">1588</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1589">1589</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1590">1590</a>         def find_some(ids, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1591">1591</a>           conditions = &quot; AND (#{sanitize_sql(options[:conditions])})&quot; if options[:conditions]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1592">1592</a>           ids_list   = ids.map { |id| quote_value(id,columns_hash[primary_key]) }.join(',')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1593">1593</a>           options.update :conditions =&gt; &quot;#{quoted_table_name}.#{connection.quote_column_name(primary_key)} IN (#{ids_list})#{conditions}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1594">1594</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1595">1595</a>           result = find_every(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1596">1596</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1597">1597</a>           # Determine expected size from limit and offset, not just ids.size.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1598">1598</a>           expected_size =</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1599">1599</a>             if options[:limit] &amp;&amp; ids.size &gt; options[:limit]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1600">1600</a>               options[:limit]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1601">1601</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1602">1602</a>               ids.size</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1603">1603</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1604">1604</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1605">1605</a>           # 11 ids with limit 3, offset 9 should give 2 results.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1606">1606</a>           if options[:offset] &amp;&amp; (ids.size - options[:offset] &lt; expected_size)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1607">1607</a>             expected_size = ids.size - options[:offset]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1608">1608</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1609">1609</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1610">1610</a>           if result.size == expected_size</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1611">1611</a>             result</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1612">1612</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1613">1613</a>             raise RecordNotFound, &quot;Couldn't find all #{name.pluralize} with IDs (#{ids_list})#{conditions} (found #{result.size} results, but was looking for #{expected_size})&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1614">1614</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1615">1615</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1616">1616</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1617">1617</a>         # Finder methods must instantiate through this method to work with the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1618">1618</a>         # single-table inheritance model that makes it possible to create</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1619">1619</a>         # objects of different types from the same table.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1620">1620</a>         def instantiate(record)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1621">1621</a>           object =</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1622">1622</a>             if subclass_name = record[inheritance_column]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1623">1623</a>               # No type given.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1624">1624</a>               if subclass_name.empty?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1625">1625</a>                 allocate</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1626">1626</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1627">1627</a>               else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1628">1628</a>                 # Ignore type if no column is present since it was probably</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1629">1629</a>                 # pulled in from a sloppy join.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1630">1630</a>                 unless columns_hash.include?(inheritance_column)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1631">1631</a>                   allocate</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1632">1632</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1633">1633</a>                 else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1634">1634</a>                   begin</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1635">1635</a>                     compute_type(subclass_name).allocate</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1636">1636</a>                   rescue NameError</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1637">1637</a>                     raise SubclassNotFound,</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1638">1638</a>                       &quot;The single-table inheritance mechanism failed to locate the subclass: '#{record[inheritance_column]}'. &quot; +</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1639">1639</a>                       &quot;This error is raised because the column '#{inheritance_column}' is reserved for storing the class in case of inheritance. &quot; +</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1640">1640</a>                       &quot;Please rename this column if you didn't intend it to be used for storing the inheritance class &quot; +</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1641">1641</a>                       &quot;or overwrite #{self.to_s}.inheritance_column to use another column for that information.&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1642">1642</a>                   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1643">1643</a>                 end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1644">1644</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1645">1645</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1646">1646</a>               allocate</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1647">1647</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1648">1648</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1649">1649</a>           object.instance_variable_set(&quot;@attributes&quot;, record)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1650">1650</a>           object.instance_variable_set(&quot;@attributes_cache&quot;, Hash.new)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1651">1651</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1652">1652</a>           if object.respond_to_without_attributes?(:after_find)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1653">1653</a>             object.send(:callback, :after_find)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1654">1654</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1655">1655</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1656">1656</a>           if object.respond_to_without_attributes?(:after_initialize)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1657">1657</a>             object.send(:callback, :after_initialize)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1658">1658</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1659">1659</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1660">1660</a>           object</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1661">1661</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1662">1662</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1663">1663</a>         # Nest the type name in the same module as this class.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1664">1664</a>         # Bar is &quot;MyApp::Business::Bar&quot; relative to MyApp::Business::Foo</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1665">1665</a>         def type_name_with_module(type_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1666">1666</a>           if store_full_sti_class</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1667">1667</a>             type_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1668">1668</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1669">1669</a>             (/^::/ =~ type_name) ? type_name : &quot;#{parent.name}::#{type_name}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1670">1670</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1671">1671</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1672">1672</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1673">1673</a>         def default_select(qualified)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1674">1674</a>           if qualified</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1675">1675</a>             quoted_table_name + '.*'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1676">1676</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1677">1677</a>             '*'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1678">1678</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1679">1679</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1680">1680</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1681">1681</a>         def construct_finder_sql(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1682">1682</a>           scope = scope(:find)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1683">1683</a>           sql  = &quot;SELECT #{options[:select] || (scope &amp;&amp; scope[:select]) || default_select(options[:joins] || (scope &amp;&amp; scope[:joins]))} &quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1684">1684</a>           sql &lt;&lt; &quot;FROM #{options[:from]  || (scope &amp;&amp; scope[:from]) || quoted_table_name} &quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1685">1685</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1686">1686</a>           add_joins!(sql, options[:joins], scope)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1687">1687</a>           add_conditions!(sql, options[:conditions], scope)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1688">1688</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1689">1689</a>           add_group!(sql, options[:group], options[:having], scope)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1690">1690</a>           add_order!(sql, options[:order], scope)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1691">1691</a>           add_limit!(sql, options, scope)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1692">1692</a>           add_lock!(sql, options, scope)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1693">1693</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1694">1694</a>           sql</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1695">1695</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1696">1696</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1697">1697</a>         # Merges includes so that the result is a valid +include+</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1698">1698</a>         def merge_includes(first, second)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1699">1699</a>          (safe_to_array(first) + safe_to_array(second)).uniq</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1700">1700</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1701">1701</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1702">1702</a>         def merge_joins(*joins)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1703">1703</a>           if joins.any?{|j| j.is_a?(String) || array_of_strings?(j) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1704">1704</a>             joins = joins.collect do |join|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1705">1705</a>               join = [join] if join.is_a?(String)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1706">1706</a>               unless array_of_strings?(join)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1707">1707</a>                 join_dependency = ActiveRecord::Associations::ClassMethods::InnerJoinDependency.new(self, join, nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1708">1708</a>                 join = join_dependency.join_associations.collect { |assoc| assoc.association_join }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1709">1709</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1710">1710</a>               join</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1711">1711</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1712">1712</a>             joins.flatten.map{|j| j.strip}.uniq</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1713">1713</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1714">1714</a>             joins.collect{|j| safe_to_array(j)}.flatten.uniq</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1715">1715</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1716">1716</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1717">1717</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1718">1718</a>         # Object#to_a is deprecated, though it does have the desired behavior</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1719">1719</a>         def safe_to_array(o)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1720">1720</a>           case o</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1721">1721</a>           when NilClass</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1722">1722</a>             []</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1723">1723</a>           when Array</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1724">1724</a>             o</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1725">1725</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1726">1726</a>             [o]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1727">1727</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1728">1728</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1729">1729</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1730">1730</a>         def array_of_strings?(o)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1731">1731</a>           o.is_a?(Array) &amp;&amp; o.all?{|obj| obj.is_a?(String)}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1732">1732</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1733">1733</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1734">1734</a>         def add_order!(sql, order, scope = :auto)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1735">1735</a>           scope = scope(:find) if :auto == scope</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1736">1736</a>           scoped_order = scope[:order] if scope</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1737">1737</a>           if order</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1738">1738</a>             sql &lt;&lt; &quot; ORDER BY #{order}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1739">1739</a>             if scoped_order &amp;&amp; scoped_order != order</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1740">1740</a>               sql &lt;&lt; &quot;, #{scoped_order}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1741">1741</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1742">1742</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1743">1743</a>             sql &lt;&lt; &quot; ORDER BY #{scoped_order}&quot; if scoped_order</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1744">1744</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1745">1745</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1746">1746</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1747">1747</a>         def add_group!(sql, group, having, scope = :auto)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1748">1748</a>           if group</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1749">1749</a>             sql &lt;&lt; &quot; GROUP BY #{group}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1750">1750</a>             sql &lt;&lt; &quot; HAVING #{sanitize_sql_for_conditions(having)}&quot; if having</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1751">1751</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1752">1752</a>             scope = scope(:find) if :auto == scope</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1753">1753</a>             if scope &amp;&amp; (scoped_group = scope[:group])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1754">1754</a>               sql &lt;&lt; &quot; GROUP BY #{scoped_group}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1755">1755</a>               sql &lt;&lt; &quot; HAVING #{sanitize_sql_for_conditions(scope[:having])}&quot; if scope[:having]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1756">1756</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1757">1757</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1758">1758</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1759">1759</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1760">1760</a>         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1761">1761</a>         def add_limit!(sql, options, scope = :auto)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1762">1762</a>           scope = scope(:find) if :auto == scope</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1763">1763</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1764">1764</a>           if scope</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1765">1765</a>             options[:limit] ||= scope[:limit]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1766">1766</a>             options[:offset] ||= scope[:offset]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1767">1767</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1768">1768</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1769">1769</a>           connection.add_limit_offset!(sql, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1770">1770</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1771">1771</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1772">1772</a>         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1773">1773</a>         # The &lt;tt&gt;:lock&lt;/tt&gt; option has precedence over a scoped &lt;tt&gt;:lock&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1774">1774</a>         def add_lock!(sql, options, scope = :auto)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1775">1775</a>           scope = scope(:find) if :auto == scope</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1776">1776</a>           options = options.reverse_merge(:lock =&gt; scope[:lock]) if scope</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1777">1777</a>           connection.add_lock!(sql, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1778">1778</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1779">1779</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1780">1780</a>         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1781">1781</a>         def add_joins!(sql, joins, scope = :auto)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1782">1782</a>           scope = scope(:find) if :auto == scope</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1783">1783</a>           merged_joins = scope &amp;&amp; scope[:joins] &amp;&amp; joins ? merge_joins(scope[:joins], joins) : (joins || scope &amp;&amp; scope[:joins])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1784">1784</a>           case merged_joins</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1785">1785</a>           when Symbol, Hash, Array</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1786">1786</a>             if array_of_strings?(merged_joins)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1787">1787</a>               sql &lt;&lt; merged_joins.join(' ') + &quot; &quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1788">1788</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1789">1789</a>               join_dependency = ActiveRecord::Associations::ClassMethods::InnerJoinDependency.new(self, merged_joins, nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1790">1790</a>               sql &lt;&lt; &quot; #{join_dependency.join_associations.collect { |assoc| assoc.association_join }.join} &quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1791">1791</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1792">1792</a>           when String</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1793">1793</a>             sql &lt;&lt; &quot; #{merged_joins} &quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1794">1794</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1795">1795</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1796">1796</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1797">1797</a>         # Adds a sanitized version of +conditions+ to the +sql+ string. Note that the passed-in +sql+ string is changed.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1798">1798</a>         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1799">1799</a>         def add_conditions!(sql, conditions, scope = :auto)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1800">1800</a>           scope = scope(:find) if :auto == scope</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1801">1801</a>           conditions = [conditions]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1802">1802</a>           conditions &lt;&lt; scope[:conditions] if scope</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1803">1803</a>           conditions &lt;&lt; type_condition if finder_needs_type_condition?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1804">1804</a>           merged_conditions = merge_conditions(*conditions)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1805">1805</a>           sql &lt;&lt; &quot;WHERE #{merged_conditions} &quot; unless merged_conditions.blank?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1806">1806</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1807">1807</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1808">1808</a>         def type_condition(table_alias=nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1809">1809</a>           quoted_table_alias = self.connection.quote_table_name(table_alias || table_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1810">1810</a>           quoted_inheritance_column = connection.quote_column_name(inheritance_column)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1811">1811</a>           type_condition = subclasses.inject(&quot;#{quoted_table_alias}.#{quoted_inheritance_column} = '#{sti_name}' &quot;) do |condition, subclass|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1812">1812</a>             condition &lt;&lt; &quot;OR #{quoted_table_alias}.#{quoted_inheritance_column} = '#{subclass.sti_name}' &quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1813">1813</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1814">1814</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1815">1815</a>           &quot; (#{type_condition}) &quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1816">1816</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1817">1817</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1818">1818</a>         # Guesses the table name, but does not decorate it with prefix and suffix information.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1819">1819</a>         def undecorated_table_name(class_name = base_class.name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1820">1820</a>           table_name = class_name.to_s.demodulize.underscore</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1821">1821</a>           table_name = table_name.pluralize if pluralize_table_names</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1822">1822</a>           table_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1823">1823</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1824">1824</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1825">1825</a>         # Enables dynamic finders like &lt;tt&gt;find_by_user_name(user_name)&lt;/tt&gt; and &lt;tt&gt;find_by_user_name_and_password(user_name, password)&lt;/tt&gt;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1826">1826</a>         # that are turned into &lt;tt&gt;find(:first, :conditions =&gt; [&quot;user_name = ?&quot;, user_name])&lt;/tt&gt; and</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1827">1827</a>         # &lt;tt&gt;find(:first, :conditions =&gt; [&quot;user_name = ? AND password = ?&quot;, user_name, password])&lt;/tt&gt; respectively. Also works for</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1828">1828</a>         # &lt;tt&gt;find(:all)&lt;/tt&gt; by using &lt;tt&gt;find_all_by_amount(50)&lt;/tt&gt; that is turned into &lt;tt&gt;find(:all, :conditions =&gt; [&quot;amount = ?&quot;, 50])&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1829">1829</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1830">1830</a>         # It's even possible to use all the additional parameters to +find+. For example, the full interface for +find_all_by_amount+</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1831">1831</a>         # is actually &lt;tt&gt;find_all_by_amount(amount, options)&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1832">1832</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1833">1833</a>         # Also enables dynamic scopes like scoped_by_user_name(user_name) and scoped_by_user_name_and_password(user_name, password) that</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1834">1834</a>         # are turned into scoped(:conditions =&gt; [&quot;user_name = ?&quot;, user_name]) and scoped(:conditions =&gt; [&quot;user_name = ? AND password = ?&quot;, user_name, password])</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1835">1835</a>         # respectively.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1836">1836</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1837">1837</a>         # Each dynamic finder, scope or initializer/creator is also defined in the class after it is first invoked, so that future</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1838">1838</a>         # attempts to use it do not run through method_missing.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1839">1839</a>         def method_missing(method_id, *arguments, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1840">1840</a>           if match = DynamicFinderMatch.match(method_id)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1841">1841</a>             attribute_names = match.attribute_names</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1842">1842</a>             super unless all_attributes_exists?(attribute_names)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1843">1843</a>             if match.finder?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1844">1844</a>               finder = match.finder</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1845">1845</a>               bang = match.bang?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1846">1846</a>               # def self.find_by_login_and_activated(*args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1847">1847</a>               #   options = args.extract_options!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1848">1848</a>               #   attributes = construct_attributes_from_arguments(</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1849">1849</a>               #     [:login,:activated],</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1850">1850</a>               #     args</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1851">1851</a>               #   )</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1852">1852</a>               #   finder_options = { :conditions =&gt; attributes }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1853">1853</a>               #   validate_find_options(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1854">1854</a>               #   set_readonly_option!(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1855">1855</a>               #</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1856">1856</a>               #   if options[:conditions]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1857">1857</a>               #     with_scope(:find =&gt; finder_options) do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1858">1858</a>               #       find(:first, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1859">1859</a>               #     end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1860">1860</a>               #   else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1861">1861</a>               #     find(:first, options.merge(finder_options))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1862">1862</a>               #   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1863">1863</a>               # end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1864">1864</a>               self.class_eval %{</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1865">1865</a>                 def self.#{method_id}(*args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1866">1866</a>                   options = args.extract_options!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1867">1867</a>                   attributes = construct_attributes_from_arguments(</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1868">1868</a>                     [:#{attribute_names.join(',:')}],</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1869">1869</a>                     args</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1870">1870</a>                   )</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1871">1871</a>                   finder_options = { :conditions =&gt; attributes }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1872">1872</a>                   validate_find_options(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1873">1873</a>                   set_readonly_option!(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1874">1874</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1875">1875</a>                   #{'result = ' if bang}if options[:conditions]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1876">1876</a>                     with_scope(:find =&gt; finder_options) do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1877">1877</a>                       find(:#{finder}, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1878">1878</a>                     end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1879">1879</a>                   else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1880">1880</a>                     find(:#{finder}, options.merge(finder_options))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1881">1881</a>                   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1882">1882</a>                   #{'result || raise(RecordNotFound, &quot;Couldn\'t find #{name} with #{attributes.to_a.collect {|pair| &quot;#{pair.first} = #{pair.second}&quot;}.join(\', \')}&quot;)' if bang}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1883">1883</a>                 end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1884">1884</a>               }, __FILE__, __LINE__</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1885">1885</a>               send(method_id, *arguments)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1886">1886</a>             elsif match.instantiator?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1887">1887</a>               instantiator = match.instantiator</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1888">1888</a>               # def self.find_or_create_by_user_id(*args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1889">1889</a>               #   guard_protected_attributes = false</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1890">1890</a>               #</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1891">1891</a>               #   if args[0].is_a?(Hash)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1892">1892</a>               #     guard_protected_attributes = true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1893">1893</a>               #     attributes = args[0].with_indifferent_access</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1894">1894</a>               #     find_attributes = attributes.slice(*[:user_id])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1895">1895</a>               #   else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1896">1896</a>               #     find_attributes = attributes = construct_attributes_from_arguments([:user_id], args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1897">1897</a>               #   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1898">1898</a>               #</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1899">1899</a>               #   options = { :conditions =&gt; find_attributes }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1900">1900</a>               #   set_readonly_option!(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1901">1901</a>               #</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1902">1902</a>               #   record = find(:first, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1903">1903</a>               #</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1904">1904</a>               #   if record.nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1905">1905</a>               #     record = self.new { |r| r.send(:attributes=, attributes, guard_protected_attributes) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1906">1906</a>               #     yield(record) if block_given?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1907">1907</a>               #     record.save</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1908">1908</a>               #     record</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1909">1909</a>               #   else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1910">1910</a>               #     record</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1911">1911</a>               #   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1912">1912</a>               # end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1913">1913</a>               self.class_eval %{</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1914">1914</a>                 def self.#{method_id}(*args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1915">1915</a>                   guard_protected_attributes = false</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1916">1916</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1917">1917</a>                   if args[0].is_a?(Hash)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1918">1918</a>                     guard_protected_attributes = true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1919">1919</a>                     attributes = args[0].with_indifferent_access</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1920">1920</a>                     find_attributes = attributes.slice(*[:#{attribute_names.join(',:')}])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1921">1921</a>                   else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1922">1922</a>                     find_attributes = attributes = construct_attributes_from_arguments([:#{attribute_names.join(',:')}], args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1923">1923</a>                   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1924">1924</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1925">1925</a>                   options = { :conditions =&gt; find_attributes }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1926">1926</a>                   set_readonly_option!(options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1927">1927</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1928">1928</a>                   record = find(:first, options)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1929">1929</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1930">1930</a>                   if record.nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1931">1931</a>                     record = self.new { |r| r.send(:attributes=, attributes, guard_protected_attributes) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1932">1932</a>                     #{'yield(record) if block_given?'}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1933">1933</a>                     #{'record.save' if instantiator == :create}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1934">1934</a>                     record</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1935">1935</a>                   else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1936">1936</a>                     record</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1937">1937</a>                   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1938">1938</a>                 end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1939">1939</a>               }, __FILE__, __LINE__</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1940">1940</a>               send(method_id, *arguments, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1941">1941</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1942">1942</a>           elsif match = DynamicScopeMatch.match(method_id)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1943">1943</a>             attribute_names = match.attribute_names</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1944">1944</a>             super unless all_attributes_exists?(attribute_names)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1945">1945</a>             if match.scope?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1946">1946</a>               self.class_eval %{</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1947">1947</a>                 def self.#{method_id}(*args)                        # def self.scoped_by_user_name_and_password(*args)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1948">1948</a>                   options = args.extract_options!                   #   options = args.extract_options!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1949">1949</a>                   attributes = construct_attributes_from_arguments( #   attributes = construct_attributes_from_arguments(</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1950">1950</a>                     [:#{attribute_names.join(',:')}], args          #     [:user_name, :password], args</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1951">1951</a>                   )                                                 #   )</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1952">1952</a>                                                                     # </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1953">1953</a>                   scoped(:conditions =&gt; attributes)                 #   scoped(:conditions =&gt; attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1954">1954</a>                 end                                                 # end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1955">1955</a>               }, __FILE__, __LINE__</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1956">1956</a>               send(method_id, *arguments)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1957">1957</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1958">1958</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1959">1959</a>             super</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1960">1960</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1961">1961</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1962">1962</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1963">1963</a>         def construct_attributes_from_arguments(attribute_names, arguments)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1964">1964</a>           attributes = {}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1965">1965</a>           attribute_names.each_with_index { |name, idx| attributes[name] = arguments[idx] }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1966">1966</a>           attributes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1967">1967</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1968">1968</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1969">1969</a>         # Similar in purpose to +expand_hash_conditions_for_aggregates+.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1970">1970</a>         def expand_attribute_names_for_aggregates(attribute_names)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1971">1971</a>           expanded_attribute_names = []</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1972">1972</a>           attribute_names.each do |attribute_name|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1973">1973</a>             unless (aggregation = reflect_on_aggregation(attribute_name.to_sym)).nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1974">1974</a>               aggregate_mapping(aggregation).each do |field_attr, aggregate_attr|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1975">1975</a>                 expanded_attribute_names &lt;&lt; field_attr</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1976">1976</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1977">1977</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1978">1978</a>               expanded_attribute_names &lt;&lt; attribute_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1979">1979</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1980">1980</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1981">1981</a>           expanded_attribute_names</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1982">1982</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1983">1983</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1984">1984</a>         def all_attributes_exists?(attribute_names)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1985">1985</a>           attribute_names = expand_attribute_names_for_aggregates(attribute_names)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1986">1986</a>           attribute_names.all? { |name| column_methods_hash.include?(name.to_sym) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1987">1987</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line1988">1988</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line1989">1989</a>         def attribute_condition(quoted_column_name, argument)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1990">1990</a>           case argument</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1991">1991</a>             when nil   then &quot;#{quoted_column_name} IS ?&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1992">1992</a>             when Array, ActiveRecord::Associations::AssociationCollection, ActiveRecord::NamedScope::Scope then &quot;#{quoted_column_name} IN (?)&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1993">1993</a>             when Range then if argument.exclude_end?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1994">1994</a>                               &quot;#{quoted_column_name} &gt;= ? AND #{quoted_column_name} &lt; ?&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1995">1995</a>                             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1996">1996</a>                               &quot;#{quoted_column_name} BETWEEN ? AND ?&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1997">1997</a>                             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1998">1998</a>             else            &quot;#{quoted_column_name} = ?&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line1999">1999</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2000">2000</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2001">2001</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2002">2002</a>         # Interpret Array and Hash as conditions and anything else as an id.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2003">2003</a>         def expand_id_conditions(id_or_conditions)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2004">2004</a>           case id_or_conditions</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2005">2005</a>             when Array, Hash then id_or_conditions</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2006">2006</a>             else sanitize_sql(primary_key =&gt; id_or_conditions)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2007">2007</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2008">2008</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2009">2009</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2010">2010</a>         # Defines an &quot;attribute&quot; method (like +inheritance_column+ or</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2011">2011</a>         # +table_name+). A new (class) method will be created with the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2012">2012</a>         # given name. If a value is specified, the new method will</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2013">2013</a>         # return that value (as a string). Otherwise, the given block</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2014">2014</a>         # will be used to compute the value of the method.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2015">2015</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2016">2016</a>         # The original method will be aliased, with the new name being</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2017">2017</a>         # prefixed with &quot;original_&quot;. This allows the new method to</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2018">2018</a>         # access the original value.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2019">2019</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2020">2020</a>         # Example:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2021">2021</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2022">2022</a>         #   class A &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2023">2023</a>         #     define_attr_method :primary_key, &quot;sysid&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2024">2024</a>         #     define_attr_method( :inheritance_column ) do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2025">2025</a>         #       original_inheritance_column + &quot;_id&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2026">2026</a>         #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2027">2027</a>         #   end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2028">2028</a>         def define_attr_method(name, value=nil, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2029">2029</a>           sing = class &lt;&lt; self; self; end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2030">2030</a>           sing.send :alias_method, &quot;original_#{name}&quot;, name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2031">2031</a>           if block_given?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2032">2032</a>             sing.send :define_method, name, &amp;block</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2033">2033</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2034">2034</a>             # use eval instead of a block to work around a memory leak in dev</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2035">2035</a>             # mode in fcgi</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2036">2036</a>             sing.class_eval &quot;def #{name}; #{value.to_s.inspect}; end&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2037">2037</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2038">2038</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2039">2039</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2040">2040</a>       protected</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2041">2041</a>         # Scope parameters to method calls within the block.  Takes a hash of method_name =&gt; parameters hash.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2042">2042</a>         # method_name may be &lt;tt&gt;:find&lt;/tt&gt; or &lt;tt&gt;:create&lt;/tt&gt;. &lt;tt&gt;:find&lt;/tt&gt; parameters may include the &lt;tt&gt;:conditions&lt;/tt&gt;, &lt;tt&gt;:joins&lt;/tt&gt;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2043">2043</a>         # &lt;tt&gt;:include&lt;/tt&gt;, &lt;tt&gt;:offset&lt;/tt&gt;, &lt;tt&gt;:limit&lt;/tt&gt;, and &lt;tt&gt;:readonly&lt;/tt&gt; options. &lt;tt&gt;:create&lt;/tt&gt; parameters are an attributes hash.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2044">2044</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2045">2045</a>         #   class Article &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2046">2046</a>         #     def self.create_with_scope</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2047">2047</a>         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot; }, :create =&gt; { :blog_id =&gt; 1 }) do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2048">2048</a>         #         find(1) # =&gt; SELECT * from articles WHERE blog_id = 1 AND id = 1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2049">2049</a>         #         a = create(1)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2050">2050</a>         #         a.blog_id # =&gt; 1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2051">2051</a>         #       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2052">2052</a>         #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2053">2053</a>         #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2054">2054</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2055">2055</a>         # In nested scopings, all previous parameters are overwritten by the innermost rule, with the exception of</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2056">2056</a>         # &lt;tt&gt;:conditions&lt;/tt&gt;, &lt;tt&gt;:include&lt;/tt&gt;, and &lt;tt&gt;:joins&lt;/tt&gt; options in &lt;tt&gt;:find&lt;/tt&gt;, which are merged.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2057">2057</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2058">2058</a>         # &lt;tt&gt;:joins&lt;/tt&gt; options are uniqued so multiple scopes can join in the same table without table aliasing</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2059">2059</a>         # problems.  If you need to join multiple tables, but still want one of the tables to be uniqued, use the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2060">2060</a>         # array of strings format for your joins.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2061">2061</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2062">2062</a>         #   class Article &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2063">2063</a>         #     def self.find_with_scope</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2064">2064</a>         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot;, :limit =&gt; 1 }, :create =&gt; { :blog_id =&gt; 1 }) do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2065">2065</a>         #         with_scope(:find =&gt; { :limit =&gt; 10 })</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2066">2066</a>         #           find(:all) # =&gt; SELECT * from articles WHERE blog_id = 1 LIMIT 10</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2067">2067</a>         #         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2068">2068</a>         #         with_scope(:find =&gt; { :conditions =&gt; &quot;author_id = 3&quot; })</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2069">2069</a>         #           find(:all) # =&gt; SELECT * from articles WHERE blog_id = 1 AND author_id = 3 LIMIT 1</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2070">2070</a>         #         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2071">2071</a>         #       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2072">2072</a>         #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2073">2073</a>         #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2074">2074</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2075">2075</a>         # You can ignore any previous scopings by using the &lt;tt&gt;with_exclusive_scope&lt;/tt&gt; method.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2076">2076</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2077">2077</a>         #   class Article &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2078">2078</a>         #     def self.find_with_exclusive_scope</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2079">2079</a>         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot;, :limit =&gt; 1 }) do</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2080">2080</a>         #         with_exclusive_scope(:find =&gt; { :limit =&gt; 10 })</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2081">2081</a>         #           find(:all) # =&gt; SELECT * from articles LIMIT 10</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2082">2082</a>         #         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2083">2083</a>         #       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2084">2084</a>         #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2085">2085</a>         #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2086">2086</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2087">2087</a>         # *Note*: the +:find+ scope also has effect on update and deletion methods,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2088">2088</a>         # like +update_all+ and +delete_all+.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2089">2089</a>         def with_scope(method_scoping = {}, action = :merge, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2090">2090</a>           method_scoping = method_scoping.method_scoping if method_scoping.respond_to?(:method_scoping)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2091">2091</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2092">2092</a>           # Dup first and second level of hash (method and params).</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2093">2093</a>           method_scoping = method_scoping.inject({}) do |hash, (method, params)|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2094">2094</a>             hash[method] = (params == true) ? params : params.dup</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2095">2095</a>             hash</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2096">2096</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2097">2097</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2098">2098</a>           method_scoping.assert_valid_keys([ :find, :create ])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2099">2099</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2100">2100</a>           if f = method_scoping[:find]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2101">2101</a>             f.assert_valid_keys(VALID_FIND_OPTIONS)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2102">2102</a>             set_readonly_option! f</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2103">2103</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2104">2104</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2105">2105</a>           # Merge scopings</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2106">2106</a>           if [:merge, :reverse_merge].include?(action) &amp;&amp; current_scoped_methods</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2107">2107</a>             method_scoping = current_scoped_methods.inject(method_scoping) do |hash, (method, params)|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2108">2108</a>               case hash[method]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2109">2109</a>                 when Hash</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2110">2110</a>                   if method == :find</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2111">2111</a>                     (hash[method].keys + params.keys).uniq.each do |key|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2112">2112</a>                       merge = hash[method][key] &amp;&amp; params[key] # merge if both scopes have the same key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2113">2113</a>                       if key == :conditions &amp;&amp; merge</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2114">2114</a>                         if params[key].is_a?(Hash) &amp;&amp; hash[method][key].is_a?(Hash)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2115">2115</a>                           hash[method][key] = merge_conditions(hash[method][key].deep_merge(params[key]))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2116">2116</a>                         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2117">2117</a>                           hash[method][key] = merge_conditions(params[key], hash[method][key])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2118">2118</a>                         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2119">2119</a>                       elsif key == :include &amp;&amp; merge</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2120">2120</a>                         hash[method][key] = merge_includes(hash[method][key], params[key]).uniq</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2121">2121</a>                       elsif key == :joins &amp;&amp; merge</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2122">2122</a>                         hash[method][key] = merge_joins(params[key], hash[method][key])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2123">2123</a>                       else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2124">2124</a>                         hash[method][key] = hash[method][key] || params[key]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2125">2125</a>                       end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2126">2126</a>                     end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2127">2127</a>                   else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2128">2128</a>                     if action == :reverse_merge</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2129">2129</a>                       hash[method] = hash[method].merge(params)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2130">2130</a>                     else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2131">2131</a>                       hash[method] = params.merge(hash[method])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2132">2132</a>                     end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2133">2133</a>                   end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2134">2134</a>                 else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2135">2135</a>                   hash[method] = params</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2136">2136</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2137">2137</a>               hash</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2138">2138</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2139">2139</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2140">2140</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2141">2141</a>           self.scoped_methods &lt;&lt; method_scoping</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2142">2142</a>           begin</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2143">2143</a>             yield</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2144">2144</a>           ensure</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2145">2145</a>             self.scoped_methods.pop</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2146">2146</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2147">2147</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2148">2148</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2149">2149</a>         # Works like with_scope, but discards any nested properties.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2150">2150</a>         def with_exclusive_scope(method_scoping = {}, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2151">2151</a>           with_scope(method_scoping, :overwrite, &amp;block)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2152">2152</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2153">2153</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2154">2154</a>         def subclasses #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2155">2155</a>           @@subclasses[self] ||= []</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2156">2156</a>           @@subclasses[self] + extra = @@subclasses[self].inject([]) {|list, subclass| list + subclass.subclasses }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2157">2157</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2158">2158</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2159">2159</a>         # Sets the default options for the model. The format of the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2160">2160</a>         # &lt;tt&gt;options&lt;/tt&gt; argument is the same as in find.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2161">2161</a>         #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2162">2162</a>         #   class Person &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2163">2163</a>         #     default_scope :order =&gt; 'last_name, first_name'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2164">2164</a>         #   end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2165">2165</a>         def default_scope(options = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2166">2166</a>           self.default_scoping &lt;&lt; { :find =&gt; options, :create =&gt; options[:conditions].is_a?(Hash) ? options[:conditions] : {} }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2167">2167</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2168">2168</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2169">2169</a>         # Test whether the given method and optional key are scoped.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2170">2170</a>         def scoped?(method, key = nil) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2171">2171</a>           if current_scoped_methods &amp;&amp; (scope = current_scoped_methods[method])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2172">2172</a>             !key || !scope[key].nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2173">2173</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2174">2174</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2175">2175</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2176">2176</a>         # Retrieve the scope for the given method and optional key.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2177">2177</a>         def scope(method, key = nil) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2178">2178</a>           if current_scoped_methods &amp;&amp; (scope = current_scoped_methods[method])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2179">2179</a>             key ? scope[key] : scope</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2180">2180</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2181">2181</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2182">2182</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2183">2183</a>         def scoped_methods #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2184">2184</a>           Thread.current[:&quot;#{self}_scoped_methods&quot;] ||= self.default_scoping.dup</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2185">2185</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2186">2186</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2187">2187</a>         def current_scoped_methods #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2188">2188</a>           scoped_methods.last</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2189">2189</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2190">2190</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2191">2191</a>         # Returns the class type of the record using the current module as a prefix. So descendants of</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2192">2192</a>         # MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2193">2193</a>         def compute_type(type_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2194">2194</a>           modularized_name = type_name_with_module(type_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2195">2195</a>           silence_warnings do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2196">2196</a>             begin</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2197">2197</a>               class_eval(modularized_name, __FILE__, __LINE__)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2198">2198</a>             rescue NameError</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2199">2199</a>               class_eval(type_name, __FILE__, __LINE__)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2200">2200</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2201">2201</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2202">2202</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2203">2203</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2204">2204</a>         # Returns the class descending directly from ActiveRecord::Base or an</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2205">2205</a>         # abstract class, if any, in the inheritance hierarchy.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2206">2206</a>         def class_of_active_record_descendant(klass)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2207">2207</a>           if klass.superclass == Base || klass.superclass.abstract_class?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2208">2208</a>             klass</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2209">2209</a>           elsif klass.superclass.nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2210">2210</a>             raise ActiveRecordError, &quot;#{name} doesn't belong in a hierarchy descending from ActiveRecord&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2211">2211</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2212">2212</a>             class_of_active_record_descendant(klass.superclass)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2213">2213</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2214">2214</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2215">2215</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2216">2216</a>         # Returns the name of the class descending directly from Active Record in the inheritance hierarchy.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2217">2217</a>         def class_name_of_active_record_descendant(klass) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2218">2218</a>           klass.base_class.name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2219">2219</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2220">2220</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2221">2221</a>         # Accepts an array, hash, or string of SQL conditions and sanitizes</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2222">2222</a>         # them into a valid SQL fragment for a WHERE clause.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2223">2223</a>         #   [&quot;name='%s' and group_id='%s'&quot;, &quot;foo'bar&quot;, 4]  returns  &quot;name='foo''bar' and group_id='4'&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2224">2224</a>         #   { :name =&gt; &quot;foo'bar&quot;, :group_id =&gt; 4 }  returns &quot;name='foo''bar' and group_id='4'&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2225">2225</a>         #   &quot;name='foo''bar' and group_id='4'&quot; returns &quot;name='foo''bar' and group_id='4'&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2226">2226</a>         def sanitize_sql_for_conditions(condition, table_name = quoted_table_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2227">2227</a>           return nil if condition.blank?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2228">2228</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2229">2229</a>           case condition</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2230">2230</a>             when Array; sanitize_sql_array(condition)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2231">2231</a>             when Hash;  sanitize_sql_hash_for_conditions(condition, table_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2232">2232</a>             else        condition</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2233">2233</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2234">2234</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2235">2235</a>         alias_method :sanitize_sql, :sanitize_sql_for_conditions</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2236">2236</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2237">2237</a>         # Accepts an array, hash, or string of SQL conditions and sanitizes</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2238">2238</a>         # them into a valid SQL fragment for a SET clause.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2239">2239</a>         #   { :name =&gt; nil, :group_id =&gt; 4 }  returns &quot;name = NULL , group_id='4'&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2240">2240</a>         def sanitize_sql_for_assignment(assignments)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2241">2241</a>           case assignments</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2242">2242</a>             when Array; sanitize_sql_array(assignments)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2243">2243</a>             when Hash;  sanitize_sql_hash_for_assignment(assignments)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2244">2244</a>             else        assignments</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2245">2245</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2246">2246</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2247">2247</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2248">2248</a>         def aggregate_mapping(reflection)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2249">2249</a>           mapping = reflection.options[:mapping] || [reflection.name, reflection.name]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2250">2250</a>           mapping.first.is_a?(Array) ? mapping : [mapping]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2251">2251</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2252">2252</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2253">2253</a>         # Accepts a hash of SQL conditions and replaces those attributes</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2254">2254</a>         # that correspond to a +composed_of+ relationship with their expanded</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2255">2255</a>         # aggregate attribute values.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2256">2256</a>         # Given:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2257">2257</a>         #     class Person &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2258">2258</a>         #       composed_of :address, :class_name =&gt; &quot;Address&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2259">2259</a>         #         :mapping =&gt; [%w(address_street street), %w(address_city city)]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2260">2260</a>         #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2261">2261</a>         # Then:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2262">2262</a>         #     { :address =&gt; Address.new(&quot;813 abc st.&quot;, &quot;chicago&quot;) }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2263">2263</a>         #       # =&gt; { :address_street =&gt; &quot;813 abc st.&quot;, :address_city =&gt; &quot;chicago&quot; }</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2264">2264</a>         def expand_hash_conditions_for_aggregates(attrs)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2265">2265</a>           expanded_attrs = {}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2266">2266</a>           attrs.each do |attr, value|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2267">2267</a>             unless (aggregation = reflect_on_aggregation(attr.to_sym)).nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2268">2268</a>               mapping = aggregate_mapping(aggregation)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2269">2269</a>               mapping.each do |field_attr, aggregate_attr|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2270">2270</a>                 if mapping.size == 1 &amp;&amp; !value.respond_to?(aggregate_attr)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2271">2271</a>                   expanded_attrs[field_attr] = value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2272">2272</a>                 else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2273">2273</a>                   expanded_attrs[field_attr] = value.send(aggregate_attr)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2274">2274</a>                 end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2275">2275</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2276">2276</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2277">2277</a>               expanded_attrs[attr] = value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2278">2278</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2279">2279</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2280">2280</a>           expanded_attrs</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2281">2281</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2282">2282</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2283">2283</a>         # Sanitizes a hash of attribute/value pairs into SQL conditions for a WHERE clause.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2284">2284</a>         #   { :name =&gt; &quot;foo'bar&quot;, :group_id =&gt; 4 }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2285">2285</a>         #     # =&gt; &quot;name='foo''bar' and group_id= 4&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2286">2286</a>         #   { :status =&gt; nil, :group_id =&gt; [1,2,3] }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2287">2287</a>         #     # =&gt; &quot;status IS NULL and group_id IN (1,2,3)&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2288">2288</a>         #   { :age =&gt; 13..18 }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2289">2289</a>         #     # =&gt; &quot;age BETWEEN 13 AND 18&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2290">2290</a>         #   { 'other_records.id' =&gt; 7 }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2291">2291</a>         #     # =&gt; &quot;`other_records`.`id` = 7&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2292">2292</a>         #   { :other_records =&gt; { :id =&gt; 7 } }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2293">2293</a>         #     # =&gt; &quot;`other_records`.`id` = 7&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2294">2294</a>         # And for value objects on a composed_of relationship:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2295">2295</a>         #   { :address =&gt; Address.new(&quot;123 abc st.&quot;, &quot;chicago&quot;) }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2296">2296</a>         #     # =&gt; &quot;address_street='123 abc st.' and address_city='chicago'&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2297">2297</a>         def sanitize_sql_hash_for_conditions(attrs, table_name = quoted_table_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2298">2298</a>           attrs = expand_hash_conditions_for_aggregates(attrs)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2299">2299</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2300">2300</a>           conditions = attrs.map do |attr, value|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2301">2301</a>             unless value.is_a?(Hash)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2302">2302</a>               attr = attr.to_s</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2303">2303</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2304">2304</a>               # Extract table name from qualified attribute names.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2305">2305</a>               if attr.include?('.')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2306">2306</a>                 table_name, attr = attr.split('.', 2)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2307">2307</a>                 table_name = connection.quote_table_name(table_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2308">2308</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2309">2309</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2310">2310</a>               attribute_condition(&quot;#{table_name}.#{connection.quote_column_name(attr)}&quot;, value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2311">2311</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2312">2312</a>               sanitize_sql_hash_for_conditions(value, connection.quote_table_name(attr.to_s))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2313">2313</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2314">2314</a>           end.join(' AND ')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2315">2315</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2316">2316</a>           replace_bind_variables(conditions, expand_range_bind_variables(attrs.values))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2317">2317</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2318">2318</a>         alias_method :sanitize_sql_hash, :sanitize_sql_hash_for_conditions</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2319">2319</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2320">2320</a>         # Sanitizes a hash of attribute/value pairs into SQL conditions for a SET clause.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2321">2321</a>         #   { :status =&gt; nil, :group_id =&gt; 1 }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2322">2322</a>         #     # =&gt; &quot;status = NULL , group_id = 1&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2323">2323</a>         def sanitize_sql_hash_for_assignment(attrs)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2324">2324</a>           attrs.map do |attr, value|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2325">2325</a>             &quot;#{connection.quote_column_name(attr)} = #{quote_bound_value(value)}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2326">2326</a>           end.join(', ')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2327">2327</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2328">2328</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2329">2329</a>         # Accepts an array of conditions.  The array has each value</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2330">2330</a>         # sanitized and interpolated into the SQL statement.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2331">2331</a>         #   [&quot;name='%s' and group_id='%s'&quot;, &quot;foo'bar&quot;, 4]  returns  &quot;name='foo''bar' and group_id='4'&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2332">2332</a>         def sanitize_sql_array(ary)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2333">2333</a>           statement, *values = ary</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2334">2334</a>           if values.first.is_a?(Hash) and statement =~ /:\w+/</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2335">2335</a>             replace_named_bind_variables(statement, values.first)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2336">2336</a>           elsif statement.include?('?')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2337">2337</a>             replace_bind_variables(statement, values)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2338">2338</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2339">2339</a>             statement % values.collect { |value| connection.quote_string(value.to_s) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2340">2340</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2341">2341</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2342">2342</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2343">2343</a>         alias_method :sanitize_conditions, :sanitize_sql</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2344">2344</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2345">2345</a>         def replace_bind_variables(statement, values) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2346">2346</a>           raise_if_bind_arity_mismatch(statement, statement.count('?'), values.size)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2347">2347</a>           bound = values.dup</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2348">2348</a>           statement.gsub('?') { quote_bound_value(bound.shift) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2349">2349</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2350">2350</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2351">2351</a>         def replace_named_bind_variables(statement, bind_vars) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2352">2352</a>           statement.gsub(/(:?):([a-zA-Z]\w*)/) do</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2353">2353</a>             if $1 == ':' # skip postgresql casts</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2354">2354</a>               $&amp; # return the whole match</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2355">2355</a>             elsif bind_vars.include?(match = $2.to_sym)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2356">2356</a>               quote_bound_value(bind_vars[match])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2357">2357</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2358">2358</a>               raise PreparedStatementInvalid, &quot;missing value for :#{match} in #{statement}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2359">2359</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2360">2360</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2361">2361</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2362">2362</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2363">2363</a>         def expand_range_bind_variables(bind_vars) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2364">2364</a>           expanded = []</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2365">2365</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2366">2366</a>           bind_vars.each do |var|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2367">2367</a>             next if var.is_a?(Hash)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2368">2368</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2369">2369</a>             if var.is_a?(Range)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2370">2370</a>               expanded &lt;&lt; var.first</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2371">2371</a>               expanded &lt;&lt; var.last</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2372">2372</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2373">2373</a>               expanded &lt;&lt; var</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2374">2374</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2375">2375</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2376">2376</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2377">2377</a>           expanded</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2378">2378</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2379">2379</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2380">2380</a>         def quote_bound_value(value) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2381">2381</a>           if value.respond_to?(:map) &amp;&amp; !value.acts_like?(:string)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2382">2382</a>             if value.respond_to?(:empty?) &amp;&amp; value.empty?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2383">2383</a>               connection.quote(nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2384">2384</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2385">2385</a>               value.map { |v| connection.quote(v) }.join(',')</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2386">2386</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2387">2387</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2388">2388</a>             connection.quote(value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2389">2389</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2390">2390</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2391">2391</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2392">2392</a>         def raise_if_bind_arity_mismatch(statement, expected, provided) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2393">2393</a>           unless expected == provided</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2394">2394</a>             raise PreparedStatementInvalid, &quot;wrong number of bind variables (#{provided} for #{expected}) in: #{statement}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2395">2395</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2396">2396</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2397">2397</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2398">2398</a>         VALID_FIND_OPTIONS = [ :conditions, :include, :joins, :limit, :offset,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2399">2399</a>                                :order, :select, :readonly, :group, :having, :from, :lock ]</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2400">2400</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2401">2401</a>         def validate_find_options(options) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2402">2402</a>           options.assert_valid_keys(VALID_FIND_OPTIONS)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2403">2403</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2404">2404</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2405">2405</a>         def set_readonly_option!(options) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2406">2406</a>           # Inherit :readonly from finder scope if set.  Otherwise,</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2407">2407</a>           # if :joins is not blank then :readonly defaults to true.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2408">2408</a>           unless options.has_key?(:readonly)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2409">2409</a>             if scoped_readonly = scope(:find, :readonly)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2410">2410</a>               options[:readonly] = scoped_readonly</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2411">2411</a>             elsif !options[:joins].blank? &amp;&amp; !options[:select]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2412">2412</a>               options[:readonly] = true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2413">2413</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2414">2414</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2415">2415</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2416">2416</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2417">2417</a>         def encode_quoted_value(value) #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2418">2418</a>           quoted_value = connection.quote(value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2419">2419</a>           quoted_value = &quot;'#{quoted_value[1..-2].gsub(/\'/, &quot;\\\\'&quot;)}'&quot; if quoted_value.include?(&quot;\\\'&quot;) # (for ruby mode) &quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2420">2420</a>           quoted_value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2421">2421</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2422">2422</a>     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2423">2423</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2424">2424</a>     public</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2425">2425</a>       # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2426">2426</a>       # attributes but not yet saved (pass a hash with key names matching the associated table column names).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2427">2427</a>       # In both instances, valid attribute keys are determined by the column names of the associated table --</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2428">2428</a>       # hence you can't have attributes that aren't part of the table columns.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2429">2429</a>       def initialize(attributes = nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2430">2430</a>         @attributes = attributes_from_column_definition</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2431">2431</a>         @attributes_cache = {}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2432">2432</a>         @new_record = true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2433">2433</a>         ensure_proper_type</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2434">2434</a>         self.attributes = attributes unless attributes.nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2435">2435</a>         self.class.send(:scope, :create).each { |att,value| self.send(&quot;#{att}=&quot;, value) } if self.class.send(:scoped?, :create)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2436">2436</a>         result = yield self if block_given?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2437">2437</a>         callback(:after_initialize) if respond_to_without_attributes?(:after_initialize)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2438">2438</a>         result</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2439">2439</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2440">2440</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2441">2441</a>       # A model instance's primary key is always available as model.id</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2442">2442</a>       # whether you name it the default 'id' or set it to something else.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2443">2443</a>       def id</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2444">2444</a>         attr_name = self.class.primary_key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2445">2445</a>         column = column_for_attribute(attr_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2446">2446</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2447">2447</a>         self.class.send(:define_read_method, :id, attr_name, column)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2448">2448</a>         # now that the method exists, call it</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2449">2449</a>         self.send attr_name.to_sym</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2450">2450</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2451">2451</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2452">2452</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2453">2453</a>       # Returns a String, which Action Pack uses for constructing an URL to this</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2454">2454</a>       # object. The default implementation returns this record's id as a String,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2455">2455</a>       # or nil if this record's unsaved.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2456">2456</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2457">2457</a>       # For example, suppose that you have a User model, and that you have a</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2458">2458</a>       # &lt;tt&gt;map.resources :users&lt;/tt&gt; route. Normally, +user_path+ will</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2459">2459</a>       # construct a path with the user object's 'id' in it:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2460">2460</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2461">2461</a>       #   user = User.find_by_name('Phusion')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2462">2462</a>       #   user_path(user)  # =&gt; &quot;/users/1&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2463">2463</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2464">2464</a>       # You can override +to_param+ in your model to make +user_path+ construct</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2465">2465</a>       # a path using the user's name instead of the user's id:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2466">2466</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2467">2467</a>       #   class User &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2468">2468</a>       #     def to_param  # overridden</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2469">2469</a>       #       name</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2470">2470</a>       #     end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2471">2471</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2472">2472</a>       #   </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2473">2473</a>       #   user = User.find_by_name('Phusion')</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2474">2474</a>       #   user_path(user)  # =&gt; &quot;/users/Phusion&quot;</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2475">2475</a>       def to_param</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2476">2476</a>         # We can't use alias_method here, because method 'id' optimizes itself on the fly.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2477">2477</a>         (id = self.id) ? id.to_s : nil # Be sure to stringify the id for routes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2478">2478</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2479">2479</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2480">2480</a>       # Returns a cache key that can be used to identify this record.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2481">2481</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2482">2482</a>       # ==== Examples</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2483">2483</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2484">2484</a>       #   Product.new.cache_key     # =&gt; &quot;products/new&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2485">2485</a>       #   Product.find(5).cache_key # =&gt; &quot;products/5&quot; (updated_at not available)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2486">2486</a>       #   Person.find(5).cache_key  # =&gt; &quot;people/5-20071224150000&quot; (updated_at available)</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2487">2487</a>       def cache_key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2488">2488</a>         case</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2489">2489</a>         when new_record?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2490">2490</a>           &quot;#{self.class.model_name.cache_key}/new&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2491">2491</a>         when timestamp = self[:updated_at]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2492">2492</a>           &quot;#{self.class.model_name.cache_key}/#{id}-#{timestamp.to_s(:number)}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2493">2493</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2494">2494</a>           &quot;#{self.class.model_name.cache_key}/#{id}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2495">2495</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2496">2496</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2497">2497</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2498">2498</a>       def id_before_type_cast #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2499">2499</a>         read_attribute_before_type_cast(self.class.primary_key)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2500">2500</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2501">2501</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2502">2502</a>       def quoted_id #:nodoc:</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2503">2503</a>         quote_value(id, column_for_attribute(self.class.primary_key))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2504">2504</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2505">2505</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2506">2506</a>       # Sets the primary ID.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2507">2507</a>       def id=(value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2508">2508</a>         write_attribute(self.class.primary_key, value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2509">2509</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2510">2510</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2511">2511</a>       # Returns true if this object hasn't been saved yet -- that is, a record for the object doesn't exist yet; otherwise, returns false.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2512">2512</a>       def new_record?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2513">2513</a>         @new_record || false</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2514">2514</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2515">2515</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2516">2516</a>       # :call-seq:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2517">2517</a>       #   save(perform_validation = true)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2518">2518</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2519">2519</a>       # Saves the model.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2520">2520</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2521">2521</a>       # If the model is new a record gets created in the database, otherwise</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2522">2522</a>       # the existing record gets updated.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2523">2523</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2524">2524</a>       # If +perform_validation+ is true validations run. If any of them fail</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2525">2525</a>       # the action is cancelled and +save+ returns +false+. If the flag is</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2526">2526</a>       # false validations are bypassed altogether. See</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2527">2527</a>       # ActiveRecord::Validations for more information. </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2528">2528</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2529">2529</a>       # There's a series of callbacks associated with +save+. If any of the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2530">2530</a>       # &lt;tt&gt;before_*&lt;/tt&gt; callbacks return +false+ the action is cancelled and</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2531">2531</a>       # +save+ returns +false+. See ActiveRecord::Callbacks for further</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2532">2532</a>       # details. </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2533">2533</a>       def save</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2534">2534</a>         create_or_update</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2535">2535</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2536">2536</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2537">2537</a>       # Saves the model.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2538">2538</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2539">2539</a>       # If the model is new a record gets created in the database, otherwise</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2540">2540</a>       # the existing record gets updated.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2541">2541</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2542">2542</a>       # With &lt;tt&gt;save!&lt;/tt&gt; validations always run. If any of them fail</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2543">2543</a>       # ActiveRecord::RecordInvalid gets raised. See ActiveRecord::Validations</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2544">2544</a>       # for more information. </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2545">2545</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2546">2546</a>       # There's a series of callbacks associated with &lt;tt&gt;save!&lt;/tt&gt;. If any of</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2547">2547</a>       # the &lt;tt&gt;before_*&lt;/tt&gt; callbacks return +false+ the action is cancelled</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2548">2548</a>       # and &lt;tt&gt;save!&lt;/tt&gt; raises ActiveRecord::RecordNotSaved. See</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2549">2549</a>       # ActiveRecord::Callbacks for further details. </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2550">2550</a>       def save!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2551">2551</a>         create_or_update || raise(RecordNotSaved)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2552">2552</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2553">2553</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2554">2554</a>       # Deletes the record in the database and freezes this instance to</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2555">2555</a>       # reflect that no changes should be made (since they can't be</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2556">2556</a>       # persisted). Returns the frozen instance.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2557">2557</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2558">2558</a>       # The row is simply removed with a SQL +DELETE+ statement on the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2559">2559</a>       # record's primary key, and no callbacks are executed.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2560">2560</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2561">2561</a>       # To enforce the object's +before_destroy+ and +after_destroy+</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2562">2562</a>       # callbacks, Observer methods, or any &lt;tt&gt;:dependent&lt;/tt&gt; association</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2563">2563</a>       # options, use &lt;tt&gt;#destroy&lt;/tt&gt;.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2564">2564</a>       def delete</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2565">2565</a>         self.class.delete(id) unless new_record?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2566">2566</a>         freeze</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2567">2567</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2568">2568</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2569">2569</a>       # Deletes the record in the database and freezes this instance to reflect that no changes should</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2570">2570</a>       # be made (since they can't be persisted).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2571">2571</a>       def destroy</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2572">2572</a>         unless new_record?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2573">2573</a>           connection.delete(</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2574">2574</a>             &quot;DELETE FROM #{self.class.quoted_table_name} &quot; +</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2575">2575</a>             &quot;WHERE #{connection.quote_column_name(self.class.primary_key)} = #{quoted_id}&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2576">2576</a>             &quot;#{self.class.name} Destroy&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2577">2577</a>           )</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2578">2578</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2579">2579</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2580">2580</a>         freeze</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2581">2581</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2582">2582</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2583">2583</a>       # Returns a clone of the record that hasn't been assigned an id yet and</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2584">2584</a>       # is treated as a new record.  Note that this is a &quot;shallow&quot; clone:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2585">2585</a>       # it copies the object's attributes only, not its associations.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2586">2586</a>       # The extent of a &quot;deep&quot; clone is application-specific and is therefore</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2587">2587</a>       # left to the application to implement according to its need.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2588">2588</a>       def clone</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2589">2589</a>         attrs = clone_attributes(:read_attribute_before_type_cast)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2590">2590</a>         attrs.delete(self.class.primary_key)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2591">2591</a>         record = self.class.new</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2592">2592</a>         record.send :instance_variable_set, '@attributes', attrs</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2593">2593</a>         record</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2594">2594</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2595">2595</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2596">2596</a>       # Returns an instance of the specified +klass+ with the attributes of the current record. This is mostly useful in relation to</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2597">2597</a>       # single-table inheritance structures where you want a subclass to appear as the superclass. This can be used along with record</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2598">2598</a>       # identification in Action Pack to allow, say, &lt;tt&gt;Client &lt; Company&lt;/tt&gt; to do something like render &lt;tt&gt;:partial =&gt; @client.becomes(Company)&lt;/tt&gt;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2599">2599</a>       # to render that instance using the companies/company partial instead of clients/client.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2600">2600</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2601">2601</a>       # Note: The new instance will share a link to the same attributes as the original class. So any change to the attributes in either</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2602">2602</a>       # instance will affect the other.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2603">2603</a>       def becomes(klass)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2604">2604</a>         returning klass.new do |became|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2605">2605</a>           became.instance_variable_set(&quot;@attributes&quot;, @attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2606">2606</a>           became.instance_variable_set(&quot;@attributes_cache&quot;, @attributes_cache)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2607">2607</a>           became.instance_variable_set(&quot;@new_record&quot;, new_record?)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2608">2608</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2609">2609</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2610">2610</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2611">2611</a>       # Updates a single attribute and saves the record without going through the normal validation procedure.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2612">2612</a>       # This is especially useful for boolean flags on existing records. The regular +update_attribute+ method</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2613">2613</a>       # in Base is replaced with this when the validations module is mixed in, which it is by default.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2614">2614</a>       def update_attribute(name, value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2615">2615</a>         send(name.to_s + '=', value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2616">2616</a>         save(false)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2617">2617</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2618">2618</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2619">2619</a>       # Updates all the attributes from the passed-in Hash and saves the record. If the object is invalid, the saving will</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2620">2620</a>       # fail and false will be returned.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2621">2621</a>       def update_attributes(attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2622">2622</a>         self.attributes = attributes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2623">2623</a>         save</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2624">2624</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2625">2625</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2626">2626</a>       # Updates an object just like Base.update_attributes but calls save! instead of save so an exception is raised if the record is invalid.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2627">2627</a>       def update_attributes!(attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2628">2628</a>         self.attributes = attributes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2629">2629</a>         save!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2630">2630</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2631">2631</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2632">2632</a>       # Initializes +attribute+ to zero if +nil+ and adds the value passed as +by+ (default is 1).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2633">2633</a>       # The increment is performed directly on the underlying attribute, no setter is invoked.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2634">2634</a>       # Only makes sense for number-based attributes. Returns +self+.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2635">2635</a>       def increment(attribute, by = 1)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2636">2636</a>         self[attribute] ||= 0</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2637">2637</a>         self[attribute] += by</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2638">2638</a>         self</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2639">2639</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2640">2640</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2641">2641</a>       # Wrapper around +increment+ that saves the record. This method differs from</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2642">2642</a>       # its non-bang version in that it passes through the attribute setter.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2643">2643</a>       # Saving is not subjected to validation checks. Returns +true+ if the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2644">2644</a>       # record could be saved.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2645">2645</a>       def increment!(attribute, by = 1)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2646">2646</a>         increment(attribute, by).update_attribute(attribute, self[attribute])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2647">2647</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2648">2648</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2649">2649</a>       # Initializes +attribute+ to zero if +nil+ and subtracts the value passed as +by+ (default is 1).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2650">2650</a>       # The decrement is performed directly on the underlying attribute, no setter is invoked.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2651">2651</a>       # Only makes sense for number-based attributes. Returns +self+.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2652">2652</a>       def decrement(attribute, by = 1)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2653">2653</a>         self[attribute] ||= 0</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2654">2654</a>         self[attribute] -= by</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2655">2655</a>         self</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2656">2656</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2657">2657</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2658">2658</a>       # Wrapper around +decrement+ that saves the record. This method differs from</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2659">2659</a>       # its non-bang version in that it passes through the attribute setter.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2660">2660</a>       # Saving is not subjected to validation checks. Returns +true+ if the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2661">2661</a>       # record could be saved.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2662">2662</a>       def decrement!(attribute, by = 1)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2663">2663</a>         decrement(attribute, by).update_attribute(attribute, self[attribute])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2664">2664</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2665">2665</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2666">2666</a>       # Assigns to +attribute+ the boolean opposite of &lt;tt&gt;attribute?&lt;/tt&gt;. So</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2667">2667</a>       # if the predicate returns +true+ the attribute will become +false+. This</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2668">2668</a>       # method toggles directly the underlying value without calling any setter.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2669">2669</a>       # Returns +self+.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2670">2670</a>       def toggle(attribute)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2671">2671</a>         self[attribute] = !send(&quot;#{attribute}?&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2672">2672</a>         self</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2673">2673</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2674">2674</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2675">2675</a>       # Wrapper around +toggle+ that saves the record. This method differs from</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2676">2676</a>       # its non-bang version in that it passes through the attribute setter.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2677">2677</a>       # Saving is not subjected to validation checks. Returns +true+ if the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2678">2678</a>       # record could be saved.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2679">2679</a>       def toggle!(attribute)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2680">2680</a>         toggle(attribute).update_attribute(attribute, self[attribute])</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2681">2681</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2682">2682</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2683">2683</a>       # Reloads the attributes of this object from the database.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2684">2684</a>       # The optional options argument is passed to find when reloading so you</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2685">2685</a>       # may do e.g. record.reload(:lock =&gt; true) to reload the same record with</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2686">2686</a>       # an exclusive row lock.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2687">2687</a>       def reload(options = nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2688">2688</a>         clear_aggregation_cache</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2689">2689</a>         clear_association_cache</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2690">2690</a>         @attributes.update(self.class.find(self.id, options).instance_variable_get('@attributes'))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2691">2691</a>         @attributes_cache = {}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2692">2692</a>         self</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2693">2693</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2694">2694</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2695">2695</a>       # Returns the value of the attribute identified by &lt;tt&gt;attr_name&lt;/tt&gt; after it has been typecast (for example,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2696">2696</a>       # &quot;2004-12-12&quot; in a data column is cast to a date object, like Date.new(2004, 12, 12)).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2697">2697</a>       # (Alias for the protected read_attribute method).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2698">2698</a>       def [](attr_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2699">2699</a>         read_attribute(attr_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2700">2700</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2701">2701</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2702">2702</a>       # Updates the attribute identified by &lt;tt&gt;attr_name&lt;/tt&gt; with the specified +value+.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2703">2703</a>       # (Alias for the protected write_attribute method).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2704">2704</a>       def []=(attr_name, value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2705">2705</a>         write_attribute(attr_name, value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2706">2706</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2707">2707</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2708">2708</a>       # Allows you to set all the attributes at once by passing in a hash with keys</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2709">2709</a>       # matching the attribute names (which again matches the column names).</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2710">2710</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2711">2711</a>       # If +guard_protected_attributes+ is true (the default), then sensitive</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2712">2712</a>       # attributes can be protected from this form of mass-assignment by using</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2713">2713</a>       # the +attr_protected+ macro. Or you can alternatively specify which</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2714">2714</a>       # attributes *can* be accessed with the +attr_accessible+ macro. Then all the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2715">2715</a>       # attributes not included in that won't be allowed to be mass-assigned.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2716">2716</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2717">2717</a>       #   class User &lt; ActiveRecord::Base</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2718">2718</a>       #     attr_protected :is_admin</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2719">2719</a>       #   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2720">2720</a>       #   </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2721">2721</a>       #   user = User.new</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2722">2722</a>       #   user.attributes = { :username =&gt; 'Phusion', :is_admin =&gt; true }</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2723">2723</a>       #   user.username   # =&gt; &quot;Phusion&quot;</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2724">2724</a>       #   user.is_admin?  # =&gt; false</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2725">2725</a>       #   </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2726">2726</a>       #   user.send(:attributes=, { :username =&gt; 'Phusion', :is_admin =&gt; true }, false)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2727">2727</a>       #   user.is_admin?  # =&gt; true</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2728">2728</a>       def attributes=(new_attributes, guard_protected_attributes = true)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2729">2729</a>         return if new_attributes.nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2730">2730</a>         attributes = new_attributes.dup</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2731">2731</a>         attributes.stringify_keys!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2732">2732</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2733">2733</a>         multi_parameter_attributes = []</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2734">2734</a>         attributes = remove_attributes_protected_from_mass_assignment(attributes) if guard_protected_attributes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2735">2735</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2736">2736</a>         attributes.each do |k, v|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2737">2737</a>           if k.include?(&quot;(&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2738">2738</a>             multi_parameter_attributes &lt;&lt; [ k, v ]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2739">2739</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2740">2740</a>             respond_to?(:&quot;#{k}=&quot;) ? send(:&quot;#{k}=&quot;, v) : raise(UnknownAttributeError, &quot;unknown attribute: #{k}&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2741">2741</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2742">2742</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2743">2743</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2744">2744</a>         assign_multiparameter_attributes(multi_parameter_attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2745">2745</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2746">2746</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2747">2747</a>       # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2748">2748</a>       def attributes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2749">2749</a>         self.attribute_names.inject({}) do |attrs, name|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2750">2750</a>           attrs[name] = read_attribute(name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2751">2751</a>           attrs</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2752">2752</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2753">2753</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2754">2754</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2755">2755</a>       # Returns a hash of attributes before typecasting and deserialization.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2756">2756</a>       def attributes_before_type_cast</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2757">2757</a>         self.attribute_names.inject({}) do |attrs, name|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2758">2758</a>           attrs[name] = read_attribute_before_type_cast(name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2759">2759</a>           attrs</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2760">2760</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2761">2761</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2762">2762</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2763">2763</a>       # Returns an &lt;tt&gt;#inspect&lt;/tt&gt;-like string for the value of the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2764">2764</a>       # attribute +attr_name+. String attributes are elided after 50</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2765">2765</a>       # characters, and Date and Time attributes are returned in the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2766">2766</a>       # &lt;tt&gt;:db&lt;/tt&gt; format. Other attributes return the value of</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2767">2767</a>       # &lt;tt&gt;#inspect&lt;/tt&gt; without modification.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2768">2768</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2769">2769</a>       #   person = Person.create!(:name =&gt; &quot;David Heinemeier Hansson &quot; * 3)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2770">2770</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2771">2771</a>       #   person.attribute_for_inspect(:name)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2772">2772</a>       #   # =&gt; '&quot;David Heinemeier Hansson David Heinemeier Hansson D...&quot;'</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2773">2773</a>       #</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2774">2774</a>       #   person.attribute_for_inspect(:created_at)</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2775">2775</a>       #   # =&gt; '&quot;2009-01-12 04:48:57&quot;'</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2776">2776</a>       def attribute_for_inspect(attr_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2777">2777</a>         value = read_attribute(attr_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2778">2778</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2779">2779</a>         if value.is_a?(String) &amp;&amp; value.length &gt; 50</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2780">2780</a>           &quot;#{value[0..50]}...&quot;.inspect</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2781">2781</a>         elsif value.is_a?(Date) || value.is_a?(Time)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2782">2782</a>           %(&quot;#{value.to_s(:db)}&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2783">2783</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2784">2784</a>           value.inspect</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2785">2785</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2786">2786</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2787">2787</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2788">2788</a>       # Returns true if the specified +attribute+ has been set by the user or by a database load and is neither</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2789">2789</a>       # nil nor empty? (the latter only applies to objects that respond to empty?, most notably Strings).</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2790">2790</a>       def attribute_present?(attribute)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2791">2791</a>         value = read_attribute(attribute)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2792">2792</a>         !value.blank?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2793">2793</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2794">2794</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2795">2795</a>       # Returns true if the given attribute is in the attributes hash</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2796">2796</a>       def has_attribute?(attr_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2797">2797</a>         @attributes.has_key?(attr_name.to_s)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2798">2798</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2799">2799</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2800">2800</a>       # Returns an array of names for the attributes available on this object sorted alphabetically.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2801">2801</a>       def attribute_names</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2802">2802</a>         @attributes.keys.sort</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2803">2803</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2804">2804</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2805">2805</a>       # Returns the column object for the named attribute.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2806">2806</a>       def column_for_attribute(name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2807">2807</a>         self.class.columns_hash[name.to_s]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2808">2808</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2809">2809</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2810">2810</a>       # Returns true if the +comparison_object+ is the same object, or is of the same type and has the same id.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2811">2811</a>       def ==(comparison_object)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2812">2812</a>         comparison_object.equal?(self) ||</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2813">2813</a>           (comparison_object.instance_of?(self.class) &amp;&amp;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2814">2814</a>             comparison_object.id == id &amp;&amp;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2815">2815</a>             !comparison_object.new_record?)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2816">2816</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2817">2817</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2818">2818</a>       # Delegates to ==</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2819">2819</a>       def eql?(comparison_object)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2820">2820</a>         self == (comparison_object)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2821">2821</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2822">2822</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2823">2823</a>       # Delegates to id in order to allow two records of the same type and id to work with something like:</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2824">2824</a>       #   [ Person.find(1), Person.find(2), Person.find(3) ] &amp; [ Person.find(1), Person.find(4) ] # =&gt; [ Person.find(1) ]</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2825">2825</a>       def hash</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2826">2826</a>         id.hash</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2827">2827</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2828">2828</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2829">2829</a>       # Freeze the attributes hash such that associations are still accessible, even on destroyed records.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2830">2830</a>       def freeze</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2831">2831</a>         @attributes.freeze; self</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2832">2832</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2833">2833</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2834">2834</a>       # Returns +true+ if the attributes hash has been frozen.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2835">2835</a>       def frozen?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2836">2836</a>         @attributes.frozen?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2837">2837</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2838">2838</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2839">2839</a>       # Returns +true+ if the record is read only. Records loaded through joins with piggy-back</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2840">2840</a>       # attributes will be marked as read only since they cannot be saved.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2841">2841</a>       def readonly?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2842">2842</a>         defined?(@readonly) &amp;&amp; @readonly == true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2843">2843</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2844">2844</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2845">2845</a>       # Marks this record as read only.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2846">2846</a>       def readonly!</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2847">2847</a>         @readonly = true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2848">2848</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2849">2849</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2850">2850</a>       # Returns the contents of the record as a nicely formatted string.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2851">2851</a>       def inspect</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2852">2852</a>         attributes_as_nice_string = self.class.column_names.collect { |name|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2853">2853</a>           if has_attribute?(name) || new_record?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2854">2854</a>             &quot;#{name}: #{attribute_for_inspect(name)}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2855">2855</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2856">2856</a>         }.compact.join(&quot;, &quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2857">2857</a>         &quot;#&lt;#{self.class} #{attributes_as_nice_string}&gt;&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2858">2858</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2859">2859</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2860">2860</a>     private</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2861">2861</a>       def create_or_update</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2862">2862</a>         raise ReadOnlyRecord if readonly?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2863">2863</a>         result = new_record? ? create : update</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2864">2864</a>         result != false</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2865">2865</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2866">2866</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2867">2867</a>       # Updates the associated record with values matching those of the instance attributes.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2868">2868</a>       # Returns the number of affected rows.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2869">2869</a>       def update(attribute_names = @attributes.keys)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2870">2870</a>         quoted_attributes = attributes_with_quotes(false, false, attribute_names)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2871">2871</a>         return 0 if quoted_attributes.empty?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2872">2872</a>         connection.update(</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2873">2873</a>           &quot;UPDATE #{self.class.quoted_table_name} &quot; +</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2874">2874</a>           &quot;SET #{quoted_comma_pair_list(connection, quoted_attributes)} &quot; +</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2875">2875</a>           &quot;WHERE #{connection.quote_column_name(self.class.primary_key)} = #{quote_value(id)}&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2876">2876</a>           &quot;#{self.class.name} Update&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2877">2877</a>         )</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2878">2878</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2879">2879</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2880">2880</a>       # Creates a record with values matching those of the instance attributes</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2881">2881</a>       # and returns its id.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2882">2882</a>       def create</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2883">2883</a>         if self.id.nil? &amp;&amp; connection.prefetch_primary_key?(self.class.table_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2884">2884</a>           self.id = connection.next_sequence_value(self.class.sequence_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2885">2885</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2886">2886</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2887">2887</a>         quoted_attributes = attributes_with_quotes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2888">2888</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2889">2889</a>         statement = if quoted_attributes.empty?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2890">2890</a>           connection.empty_insert_statement(self.class.table_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2891">2891</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2892">2892</a>           &quot;INSERT INTO #{self.class.quoted_table_name} &quot; +</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2893">2893</a>           &quot;(#{quoted_column_names.join(', ')}) &quot; +</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2894">2894</a>           &quot;VALUES(#{quoted_attributes.values.join(', ')})&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2895">2895</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2896">2896</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2897">2897</a>         self.id = connection.insert(statement, &quot;#{self.class.name} Create&quot;,</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2898">2898</a>           self.class.primary_key, self.id, self.class.sequence_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2899">2899</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2900">2900</a>         @new_record = false</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2901">2901</a>         id</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2902">2902</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2903">2903</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2904">2904</a>       # Sets the attribute used for single table inheritance to this class name if this is not the ActiveRecord::Base descendant.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2905">2905</a>       # Considering the hierarchy Reply &lt; Message &lt; ActiveRecord::Base, this makes it possible to do Reply.new without having to</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2906">2906</a>       # set &lt;tt&gt;Reply[Reply.inheritance_column] = &quot;Reply&quot;&lt;/tt&gt; yourself. No such attribute would be set for objects of the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2907">2907</a>       # Message class in that example.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2908">2908</a>       def ensure_proper_type</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2909">2909</a>         unless self.class.descends_from_active_record?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2910">2910</a>           write_attribute(self.class.inheritance_column, self.class.sti_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2911">2911</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2912">2912</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2913">2913</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2914">2914</a>       def convert_number_column_value(value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2915">2915</a>         if value == false</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2916">2916</a>           0</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2917">2917</a>         elsif value == true</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2918">2918</a>           1</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2919">2919</a>         elsif value.is_a?(String) &amp;&amp; value.blank?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2920">2920</a>           nil</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2921">2921</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2922">2922</a>           value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2923">2923</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2924">2924</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2925">2925</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2926">2926</a>       def remove_attributes_protected_from_mass_assignment(attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2927">2927</a>         safe_attributes =</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2928">2928</a>           if self.class.accessible_attributes.nil? &amp;&amp; self.class.protected_attributes.nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2929">2929</a>             attributes.reject { |key, value| attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2930">2930</a>           elsif self.class.protected_attributes.nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2931">2931</a>             attributes.reject { |key, value| !self.class.accessible_attributes.include?(key.gsub(/\(.+/, &quot;&quot;)) || attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2932">2932</a>           elsif self.class.accessible_attributes.nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2933">2933</a>             attributes.reject { |key, value| self.class.protected_attributes.include?(key.gsub(/\(.+/,&quot;&quot;)) || attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2934">2934</a>           else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2935">2935</a>             raise &quot;Declare either attr_protected or attr_accessible for #{self.class}, but not both.&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2936">2936</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2937">2937</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2938">2938</a>         removed_attributes = attributes.keys - safe_attributes.keys</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2939">2939</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2940">2940</a>         if removed_attributes.any?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2941">2941</a>           log_protected_attribute_removal(removed_attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2942">2942</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2943">2943</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2944">2944</a>         safe_attributes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2945">2945</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2946">2946</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2947">2947</a>       # Removes attributes which have been marked as readonly.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2948">2948</a>       def remove_readonly_attributes(attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2949">2949</a>         unless self.class.readonly_attributes.nil?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2950">2950</a>           attributes.delete_if { |key, value| self.class.readonly_attributes.include?(key.gsub(/\(.+/,&quot;&quot;)) }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2951">2951</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2952">2952</a>           attributes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2953">2953</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2954">2954</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2955">2955</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2956">2956</a>       def log_protected_attribute_removal(*attributes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2957">2957</a>         logger.debug &quot;WARNING: Can't mass-assign these protected attributes: #{attributes.join(', ')}&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2958">2958</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2959">2959</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2960">2960</a>       # The primary key and inheritance column can never be set by mass-assignment for security reasons.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2961">2961</a>       def attributes_protected_by_default</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2962">2962</a>         default = [ self.class.primary_key, self.class.inheritance_column ]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2963">2963</a>         default &lt;&lt; 'id' unless self.class.primary_key.eql? 'id'</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2964">2964</a>         default</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2965">2965</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2966">2966</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2967">2967</a>       # Returns a copy of the attributes hash where all the values have been safely quoted for use in</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2968">2968</a>       # an SQL statement.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2969">2969</a>       def attributes_with_quotes(include_primary_key = true, include_readonly_attributes = true, attribute_names = @attributes.keys)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2970">2970</a>         quoted = {}</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2971">2971</a>         connection = self.class.connection</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2972">2972</a>         attribute_names.each do |name|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2973">2973</a>           if (column = column_for_attribute(name)) &amp;&amp; (include_primary_key || !column.primary)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2974">2974</a>             value = read_attribute(name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2975">2975</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2976">2976</a>             # We need explicit to_yaml because quote() does not properly convert Time/Date fields to YAML.</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2977">2977</a>             if value &amp;&amp; self.class.serialized_attributes.has_key?(name) &amp;&amp; (value.acts_like?(:date) || value.acts_like?(:time))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2978">2978</a>               value = value.to_yaml</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2979">2979</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2980">2980</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2981">2981</a>             quoted[name] = connection.quote(value, column)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2982">2982</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2983">2983</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2984">2984</a>         include_readonly_attributes ? quoted : remove_readonly_attributes(quoted)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2985">2985</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2986">2986</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2987">2987</a>       # Quote strings appropriately for SQL statements.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2988">2988</a>       def quote_value(value, column = nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2989">2989</a>         self.class.connection.quote(value, column)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2990">2990</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2991">2991</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2992">2992</a>       # Interpolate custom SQL string in instance context.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2993">2993</a>       # Optional record argument is meant for custom insert_sql.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line2994">2994</a>       def interpolate_sql(sql, record = nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2995">2995</a>         instance_eval(&quot;%@#{sql.gsub('@', '\@')}@&quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line2996">2996</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2997">2997</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2998">2998</a>       # Initializes the attributes array with keys matching the columns from the linked table and</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line2999">2999</a>       # the values matching the corresponding default value of that column, so</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3000">3000</a>       # that a new instance, or one populated from a passed-in Hash, still has all the attributes</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3001">3001</a>       # that instances loaded from the database would.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3002">3002</a>       def attributes_from_column_definition</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3003">3003</a>         self.class.columns.inject({}) do |attributes, column|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3004">3004</a>           attributes[column.name] = column.default unless column.name == self.class.primary_key</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3005">3005</a>           attributes</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3006">3006</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3007">3007</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3008">3008</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3009">3009</a>       # Instantiates objects for all attribute classes that needs more than one constructor parameter. This is done</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3010">3010</a>       # by calling new on the column type or aggregation type (through composed_of) object with these parameters.</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3011">3011</a>       # So having the pairs written_on(1) = &quot;2004&quot;, written_on(2) = &quot;6&quot;, written_on(3) = &quot;24&quot;, will instantiate</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3012">3012</a>       # written_on (a date type) with Date.new(&quot;2004&quot;, &quot;6&quot;, &quot;24&quot;). You can also specify a typecast character in the</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3013">3013</a>       # parentheses to have the parameters typecasted before they're used in the constructor. Use i for Fixnum, f for Float,</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3014">3014</a>       # s for String, and a for Array. If all the values for a given attribute are empty, the attribute will be set to nil.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3015">3015</a>       def assign_multiparameter_attributes(pairs)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3016">3016</a>         execute_callstack_for_multiparameter_attributes(</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3017">3017</a>           extract_callstack_for_multiparameter_attributes(pairs)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3018">3018</a>         )</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3019">3019</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3020">3020</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3021">3021</a>       def instantiate_time_object(name, values)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3022">3022</a>         if self.class.send(:create_time_zone_conversion_attribute?, name, column_for_attribute(name))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3023">3023</a>           Time.zone.local(*values)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3024">3024</a>         else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3025">3025</a>           Time.time_with_datetime_fallback(@@default_timezone, *values)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3026">3026</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3027">3027</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3028">3028</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3029">3029</a>       def execute_callstack_for_multiparameter_attributes(callstack)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3030">3030</a>         errors = []</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3031">3031</a>         callstack.each do |name, values|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3032">3032</a>           begin</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3033">3033</a>             klass = (self.class.reflect_on_aggregation(name.to_sym) || column_for_attribute(name)).klass</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3034">3034</a>             if values.empty?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3035">3035</a>               send(name + &quot;=&quot;, nil)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3036">3036</a>             else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3037">3037</a>               value = if Time == klass</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3038">3038</a>                 instantiate_time_object(name, values)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3039">3039</a>               elsif Date == klass</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3040">3040</a>                 begin</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3041">3041</a>                   Date.new(*values)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3042">3042</a>                 rescue ArgumentError =&gt; ex # if Date.new raises an exception on an invalid date</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3043">3043</a>                   instantiate_time_object(name, values).to_date # we instantiate Time object and convert it back to a date thus using Time's logic in handling invalid dates</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3044">3044</a>                 end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3045">3045</a>               else</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3046">3046</a>                 klass.new(*values)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3047">3047</a>               end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3048">3048</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3049">3049</a>               send(name + &quot;=&quot;, value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3050">3050</a>             end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3051">3051</a>           rescue =&gt; ex</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3052">3052</a>             errors &lt;&lt; AttributeAssignmentError.new(&quot;error on assignment #{values.inspect} to #{name}&quot;, ex, name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3053">3053</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3054">3054</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3055">3055</a>         unless errors.empty?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3056">3056</a>           raise MultiparameterAssignmentErrors.new(errors), &quot;#{errors.size} error(s) on assignment of multiparameter attributes&quot;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3057">3057</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3058">3058</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3059">3059</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3060">3060</a>       def extract_callstack_for_multiparameter_attributes(pairs)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3061">3061</a>         attributes = { }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3062">3062</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3063">3063</a>         for pair in pairs</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3064">3064</a>           multiparameter_name, value = pair</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3065">3065</a>           attribute_name = multiparameter_name.split(&quot;(&quot;).first</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3066">3066</a>           attributes[attribute_name] = [] unless attributes.include?(attribute_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3067">3067</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3068">3068</a>           unless value.empty?</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3069">3069</a>             attributes[attribute_name] &lt;&lt;</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3070">3070</a>               [ find_parameter_position(multiparameter_name), type_cast_attribute_value(multiparameter_name, value) ]</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3071">3071</a>           end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3072">3072</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3073">3073</a> </pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3074">3074</a>         attributes.each { |name, values| attributes[name] = values.sort_by{ |v| v.first }.collect { |v| v.last } }</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3075">3075</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3076">3076</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3077">3077</a>       def type_cast_attribute_value(multiparameter_name, value)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3078">3078</a>         multiparameter_name =~ /\([0-9]*([if])\)/ ? value.send(&quot;to_&quot; + $1) : value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3079">3079</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3080">3080</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3081">3081</a>       def find_parameter_position(multiparameter_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3082">3082</a>         multiparameter_name.scan(/\(([0-9]*).*\)/).first.first</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3083">3083</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3084">3084</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3085">3085</a>       # Returns a comma-separated pair list, like &quot;key1 = val1, key2 = val2&quot;.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3086">3086</a>       def comma_pair_list(hash)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3087">3087</a>         hash.inject([]) { |list, pair| list &lt;&lt; &quot;#{pair.first} = #{pair.last}&quot; }.join(&quot;, &quot;)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3088">3088</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3089">3089</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3090">3090</a>       def quoted_column_names(attributes = attributes_with_quotes)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3091">3091</a>         connection = self.class.connection</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3092">3092</a>         attributes.keys.collect do |column_name|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3093">3093</a>           connection.quote_column_name(column_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3094">3094</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3095">3095</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3096">3096</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3097">3097</a>       def self.quoted_table_name</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3098">3098</a>         self.connection.quote_table_name(self.table_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3099">3099</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3100">3100</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3101">3101</a>       def quote_columns(quoter, hash)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3102">3102</a>         hash.inject({}) do |quoted, (name, value)|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3103">3103</a>           quoted[quoter.quote_column_name(name)] = value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3104">3104</a>           quoted</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3105">3105</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3106">3106</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3107">3107</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3108">3108</a>       def quoted_comma_pair_list(quoter, hash)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3109">3109</a>         comma_pair_list(quote_columns(quoter, hash))</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3110">3110</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3111">3111</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3112">3112</a>       def object_from_yaml(string)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3113">3113</a>         return string unless string.is_a?(String) &amp;&amp; string =~ /^---/</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3114">3114</a>         YAML::load(string) rescue string</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3115">3115</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3116">3116</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3117">3117</a>       def clone_attributes(reader_method = :read_attribute, attributes = {})</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3118">3118</a>         self.attribute_names.inject(attributes) do |attrs, name|</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3119">3119</a>           attrs[name] = clone_attribute_value(reader_method, name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3120">3120</a>           attrs</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3121">3121</a>         end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3122">3122</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3123">3123</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3124">3124</a>       def clone_attribute_value(reader_method, attribute_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3125">3125</a>         value = send(reader_method, attribute_name)</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3126">3126</a>         value.duplicable? ? value.clone : value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3127">3127</a>       rescue TypeError, NoMethodError</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3128">3128</a>         value</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3129">3129</a>       end</pre></td>
          </tr>
        
          
          
          <tr class="uncovered">
            <td><pre><a name="line3130">3130</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3131">3131</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3132">3132</a>   Base.class_eval do</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3133">3133</a>     extend QueryCache::ClassMethods</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3134">3134</a>     include Validations</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3135">3135</a>     include Locking::Optimistic, Locking::Pessimistic</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3136">3136</a>     include AttributeMethods</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3137">3137</a>     include Dirty</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3138">3138</a>     include Callbacks, Observing, Timestamp</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3139">3139</a>     include Associations, AssociationPreload, NamedScope</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3140">3140</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3141">3141</a>     # AutosaveAssociation needs to be included before Transactions, because we want</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3142">3142</a>     # #save_with_autosave_associations to be wrapped inside a transaction.</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3143">3143</a>     include AutosaveAssociation, NestedAttributes</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3144">3144</a> </pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3145">3145</a>     include Aggregations, Transactions, Reflection, Batches, Calculations, Serialization</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3146">3146</a>   end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3147">3147</a> end</pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3148">3148</a> </pre></td>
          </tr>
        
          
          
          <tr class="inferred">
            <td><pre><a name="line3149">3149</a> # TODO: Remove this and make it work with LAZY flag</pre></td>
          </tr>
        
          
          
          <tr class="marked">
            <td><pre><a name="line3150">3150</a> require 'active_record/connection_adapters/abstract_adapter'</pre></td>
          </tr>
        
      </tbody>
    </table>

    <p>Generated on Sat Oct 10 16:43:25 -0400 2009 with <a href="http://github.com/relevance/rcov">rcov 0.9.3</a></p>

  </body>
</html>
